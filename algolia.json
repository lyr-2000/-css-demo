[{"content":"js bom 对象 clipboard 对象 为了使 JavaScript 更加灵活的操作剪切板，也是为了顺应 JS 发展的历史潮流，Clipboard API 应运而生。它是下一代的剪贴板操作方法，比传统的","lvl0":"js的bom","lvl1":["js高级"],"lvl2":"摘要","objectID":"ab74585617c9563b705cd1fc8c3b2aa9","tags":["js高级"],"url":"https://lyr-2000.github.io/html/post/js%E9%AB%98%E7%BA%A7/js%E7%9A%84bom/"},{"content":"JS 的类型 基本类型： undefined, null, boolean, number, string , object ,symbol 引用类型： Boolean,Number, String, Symbol, Object ,Array, Map, Set 1 2 3 4 5 6 7 8 9 // 基本类型 typeof(\u0026#34;aa\u0026#34;) typeof(undefined) typeof(Symbol(\u0026#34;aa\u0026#34;)) // 引用类型 new String(\u0026#34;aa\u0026#34;) instanceof String [] instanceof Array 小数转二进制 4.12, 4,0.12 $$ 0.1 2 =","lvl0":"js类型","lvl1":["js高级"],"lvl2":"摘要","objectID":"e4e40e1361ca9c6efaf2dcf255f2454f","tags":["js高级"],"url":"https://lyr-2000.github.io/html/post/js%E9%AB%98%E7%BA%A7/js%E7%B1%BB%E5%9E%8B/"},{"content":"自定义组件处理 图标 参考博客 自定义组件处理 自定义 svg图标形式 自定义组件的能力： 显示外部svg图标 显示项目内svg图标 1 2 3 4 5 6 7 8 9 10 11 12","lvl0":"icon图标处理方案","lvl1":["vue"],"lvl2":"摘要","objectID":"d6bc53102a5860bea90e53f2e41967fe","tags":["vue"],"url":"https://lyr-2000.github.io/html/post/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/vue/icon%E5%9B%BE%E6%A0%87%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/"},{"content":"项目引入 element-plus 1 vue add element-plus @vue/cli 在帮助我们创建项目的同时，也生成了很多无用的代码，那么这一小节我们需要去除掉这些无用的代码。 router/index.js 中初始化代码如下： 1 2 3 4","lvl0":"vue3样式穿透vdeep","lvl1":["vue"],"lvl2":"摘要","objectID":"0c3b9fc7aa4872d6d123fd3b5b41cebb","tags":["vue"],"url":"https://lyr-2000.github.io/html/post/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/vue/vue3%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8Fvdeep/"},{"content":"js事件循环 1 2 3 4 5 setTimeout (function () { console.log(\u0026#34;2\u0026#34;); },500); alert(\u0026#34;----\u0026#34;) ;//如果alert一直不退出，定时器将无法执行 Promise 解决回调地狱问题 See the Pen Untitled by 凌冬 (@lindong) on CodePen. 使用 Promise 解决回调地狱","lvl0":"js串行和事件循环","lvl1":["h5必知必会"],"lvl2":"摘要","objectID":"8d6e797403265dcb505d27d0fcbfba04","tags":["h5必知必会"],"url":"https://lyr-2000.github.io/html/post/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/h5%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/js%E4%B8%B2%E8%A1%8C%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"content":"h5新增的存储方案 存储方案对比 存储方案 生命周期 大小限制 cookie 默认是关闭浏览器失效，但是也可以设置过期时间失效 4k左右 (20~50个 cookie现","lvl0":"h5新增存储理解","lvl1":["h5必知必会"],"lvl2":"摘要","objectID":"15ee05d14bc017347fa2abe66f09ef2a","tags":["h5必知必会"],"url":"https://lyr-2000.github.io/html/post/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/h5%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/h5%E6%96%B0%E5%A2%9E%E5%AD%98%E5%82%A8%E7%90%86%E8%A7%A3/"},{"content":"vite项目构建 1 npm init vite@latest","lvl0":"vue3项目学习","lvl1":["项目学习"],"lvl2":"摘要","objectID":"3e901ae71b5eb44ce887483aba850319","tags":["项目学习"],"url":"https://lyr-2000.github.io/html/post/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/vue3%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"content":"学习网站收集 css 学习网站 css trick , 链接 chrome浏览器插件 web maker","lvl0":"学习网站记录","lvl1":["其他"],"lvl2":"摘要","objectID":"3f52ea3e4aa04390d69b9ce65b84b201","tags":["其他"],"url":"https://lyr-2000.github.io/html/post/%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E8%AE%B0%E5%BD%95/"},{"content":"es6语法 关键字 用法 var 变量 let es6的新关键字 const 常量 var 和let 有一个问题就是 变量覆盖，如下 1 2 3 4 5 6 7 8 9 10 11 var num = {a:1}; var num=1; // 这样上一个变量就","lvl0":"es6语法","lvl1":["js"],"lvl2":"摘要","objectID":"485ba62496aa2caa2a751dfdb672c16a","tags":["js"],"url":"https://lyr-2000.github.io/html/post/js%E9%AB%98%E7%BA%A7/es6%E8%AF%AD%E6%B3%95/"},{"content":"js闭包问题 Closure 闭包可以理解为延长变量定义 1 2 3 4 5 6 7 8 9 function a() { let u = 1; return function() { return u++ } } let b = a(); console.log(b(),b(),b()); //返回 1,2,3等 闭包的作用 延长对象的生命","lvl0":"js闭包","lvl1":["js"],"lvl2":"摘要","objectID":"3b6dcef74a611017b8047c7caf94a1ff","tags":["js"],"url":"https://lyr-2000.github.io/html/post/js%E9%AB%98%E7%BA%A7/js%E9%97%AD%E5%8C%85/"},{"content":"编译原理 ​ 相关概念 语法分析器 parser 词法分析器 lexer 语法规则： BNF , expr -\u0026gt; factor+ expr | factor 通过抽象语法树生成中间代码（比如三地址代码，并且对中间代码进行存储，优化","lvl0":"编译原理","lvl1":["01.操作系统"],"lvl2":"摘要","objectID":"b3160e4430e5eecf2e19b33050c20f37","tags":["01.操作系统"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"content":"11.unsafe ​ golang 可以通过 unsafe 获取私有变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 type Student struct { Name string Age int } func main() { s := Student{} s.Name = \u0026#34;Peter\u0026#34; s.Age = 33 pStudent := unsafe.Pointer(\u0026amp;s) // 整个对象转换成指针","lvl0":"11.unsafe","lvl1":["01.Go"],"lvl2":"摘要","objectID":"eaf5d29a50e2b5761973d7f67f9aee75","tags":["01.Go"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/11.unsafe/"},{"content":"7.元编程 ​ 这里主要包括插件系统以及代码生成这两个部分，鉴于面试应该不会问这个问题，所以我就不写了","lvl0":"7.元编程","lvl1":["01.Go"],"lvl2":"摘要","objectID":"aa4ad0ec70a8c7c500718251749d609e","tags":["01.Go"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/7.%E5%85%83%E7%BC%96%E7%A8%8B/"},{"content":"9.其他 ​ Go的基本命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 用于打包编译代码 go build // 来移除当前源码包和关联源码包里面编译生成的文件","lvl0":"9.其他","lvl1":["01.Go"],"lvl2":"摘要","objectID":"184203a391955a7bc9880b6d78b208e7","tags":["01.Go"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/9.%E5%85%B6%E4%BB%96/"},{"content":"5.并发编程 ​ 上下文context 这东西是用于控制并发的。下面是一个简单的例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31","lvl0":"5.并发编程","lvl1":["01.Go"],"lvl2":"摘要","objectID":"6e8866b035b9ff799d4214ca3dfd34c5","tags":["01.Go"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/5.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"content":"1.编译原理 ​ 基本概念 抽象语法树 是源代码语法的结构的一种抽象表示，它用树状的方式表示编程语言的语法结构1。抽象语法树中的每一个节点都表示源代","lvl0":"1.编译原理","lvl1":["01.Go"],"lvl2":"摘要","objectID":"40df418bedee0044b971c20039f18960","tags":["01.Go"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/1.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"content":"10.面试问题 ​ 基础相关 map怎么实现顺序读取 把map中的key通过sort包排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; )","lvl0":"10.面试问题","lvl1":["01.Go"],"lvl2":"摘要","objectID":"4d2b7c652135d2eefbbf700c3cbba508","tags":["01.Go"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/10.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"},{"content":"6.内存管理 ​ 程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间包含两个重要区域：栈区（Stack）和堆区（Heap）。函数调用的","lvl0":"6.内存管理","lvl1":["01.Go"],"lvl2":"摘要","objectID":"1a5eaa0e5171b1b1b7c623d3d7c09841","tags":["01.Go"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/6.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"content":"8.标准库 ​ JSON 序列化和反序列化 go的序列化大部分指的是把结构体转换为json数据，在序列化的时候要注意变量名必须要大写，小写字母开头的变量是","lvl0":"8.标准库","lvl1":["01.Go"],"lvl2":"摘要","objectID":"54f177bb312bd355bb1744f86677c110","tags":["01.Go"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/8.%E6%A0%87%E5%87%86%E5%BA%93/"},{"content":"毕业论文编辑注意事项 ​ word 参考文献","lvl0":"毕业论文编辑注意事项","lvl1":null,"lvl2":"摘要","objectID":"c0d9ce2abc9fed3b8b09f31ce7fc0cc0","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/07.%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E7%BC%96%E8%BE%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"content":"考研408复习笔记 目的专业：计算机科学与技术 预计考研专业课科目：408 （第一次发现原来gayhub也可以用来存放学习笔记哇） 主要包括408以","lvl0":"readme","lvl1":null,"lvl2":"摘要","objectID":"baf33b28216cdabc31f4180e73aef42d","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/02_2.408%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A4%8D%E4%B9%A0/readme/"},{"content":"《计算机网络》复习笔记 这个笔记同时使用了两本教材：《计算机网络：自顶向下方法（原书第六版）》和《计算机网络（谢希仁 第七版）》， 目录结构按照自","lvl0":"计算机网络复习_","lvl1":null,"lvl2":"摘要","objectID":"bcf75676780fcdb28f18a028b2d03124","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/02_2.408%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"},{"content":"Docker Docker 组件 组件 Docker Daemon（Dockerd）：Docker容器管理的守护进程，负责和Docker client交互，并管理Docker镜像、容","lvl0":"网友总结-2021 秋招结束后- Docker","lvl1":null,"lvl2":"摘要","objectID":"b981b7453d61d7877a06a18563ada2ac","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/%E7%BD%91%E5%8F%8B%E6%80%BB%E7%BB%93/docker_k8s/docker/"},{"content":"IPC通信 IPC 标识符（ID）：ID是IPC结构的内部名，用来确保使用同一个通讯通道，消息队列、信号量和共享存储段都属于内核中的IPC结构，它们","lvl0":"网友总结-2021 秋招结束后- IPC 通信","lvl1":null,"lvl2":"摘要","objectID":"5a0f7f33dc11ccbf74b4036628e81689","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/%E7%BD%91%E5%8F%8B%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ipc%E9%80%9A%E4%BF%A1/"},{"content":"Mysql 基础架构 server层 连接器：管理连接，权限验证 使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的","lvl0":"网友总结-2021 秋招结束后- Mysql","lvl1":null,"lvl2":"摘要","objectID":"42ad2defac1a09bfd8a3eaec69891313","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/%E7%BD%91%E5%8F%8B%E6%80%BB%E7%BB%93/mysql/mysql/"},{"content":"Linux Namespace UTS Namespace 进程task结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 每个进程对应的task结构体struct task_struct中，增加了一个叫n","lvl0":"网友总结-2021 秋招结束后- namespace","lvl1":null,"lvl2":"摘要","objectID":"1c6c1fd8c11392342c5dad824a39fb4a","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/%E7%BD%91%E5%8F%8B%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/namespace/"},{"content":"redis 数据结构 字符串 列表 哈希表 set sort set Bitmaps BloomFilter HyperLogLog Pub/Sub Redis Module RedisSearch Redis-ML redis数据结构 sds字符串 1 2 3 4 5 6 7 8 struct sdshdr { //字符长度 unsigned int len; //当前可用空间 unsigned int free;","lvl0":"网友总结-2021 秋招结束后- Redis","lvl1":null,"lvl2":"摘要","objectID":"4755b3051bc8ba8a0887e9e59fdb653a","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/%E7%BD%91%E5%8F%8B%E6%80%BB%E7%BB%93/redis/redis/"},{"content":"进程与线程 task_struct 进程状态 5个互斥状态： 状态 描述 TASK_RUNNING 表示进程要么正在执行，要么正要准备执行（已经就绪），正在等待cpu时间片的调度 TASK_INTERRUPTIBLE 进程因为等待一些","lvl0":"网友总结-2021 秋招结束后- 进程和线程","lvl1":null,"lvl2":"摘要","objectID":"a1bb6d22d976a899f4bc33495ccf3b84","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/%E7%BD%91%E5%8F%8B%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"},{"content":"内存 Linux 内存概述 UMA和NUMA两种模型 均匀存储器存取（Uniform-Memory-Access，简称UMA）模型：传统的多核运算是使用SM","lvl0":"网友总结-2021 秋招结束后- 内存","lvl1":null,"lvl2":"摘要","objectID":"0ca165022b9c8345e150369dfa1e208c","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/%E7%BD%91%E5%8F%8B%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98/"},{"content":"网络 OSI，TCP/IP，五层协议的体系结构 OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 TCP/IP分层（","lvl0":"网友总结-2021 秋招结束后- 网络","lvl1":null,"lvl2":"摘要","objectID":"47eb32d6a61d3bf4da2d49f7670ff58e","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/%E7%BD%91%E5%8F%8B%E6%80%BB%E7%BB%93/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/"},{"content":"文件系统 Linux mount 挂载概念 Linux中的根目录以外的文件要想被访问，需要将其挂载到根目录下的某个目录来实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20","lvl0":"网友总结-2021 秋招结束后- 文件系统","lvl1":null,"lvl2":"摘要","objectID":"36fc63b0c38d5f48a8165c5d7808cc08","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/%E7%BD%91%E5%8F%8B%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"content":"三方协议注意事项 https://www.bilibili.com/video/BV1zb4y1874q?from=search\u0026amp;seid=1139540341837427465\u0026amp;spm_id_from=333.337.0.0 千万别让档案变成死档｜档案、户口、报到证、三方协议 作者：小甜橘~【该账号已停用】 链接：https://www.nowcod","lvl0":"三方协议注意事项","lvl1":null,"lvl2":"摘要","objectID":"b84ea02008b76fb29137c63523d9f2b3","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/00.%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0/%E6%AF%95%E4%B8%9A%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%B8%89%E6%96%B9%E5%8D%8F%E8%AE%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"content":"创业公司确实不容易，老板起早贪黑，员工亦是没日没夜地干活。但这中间，一旦哪个环节出现问题，就有可能导致整个公司都崩盘。 小王去了一家 P2P 创业公司","lvl0":"打工人注意点","lvl1":["法律"],"lvl2":"摘要","objectID":"c1da11b0de073b5e25ffde129a8a5bd3","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/05.%E6%B3%95%E5%BE%8B/%E6%89%93%E5%B7%A5%E4%BA%BA%E6%B3%A8%E6%84%8F%E7%82%B9/"},{"content":"现在创业公司员工的两大迷雾，无非是相当火热的“股权”和“期权”。前面我们学完股权内容后，不少留言都在问，期权究竟是怎么回事，离职后期权要怎么","lvl0":"股权","lvl1":["法律"],"lvl2":"摘要","objectID":"44b3520d5adc09a9d4e6808016124a45","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/05.%E6%B3%95%E5%BE%8B/%E8%82%A1%E6%9D%83/"},{"content":"首先我们要了解加班时间的规定。我们实行的是 8 小时工作制，但并没有禁止公司安排 8 小时外的加班，只不过，法律上要求，公司安排加班，必须符合《劳动","lvl0":"加班费怎么算？","lvl1":["法律"],"lvl2":"摘要","objectID":"8ca6edfce977b263e2da59e36183b24a","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/05.%E6%B3%95%E5%BE%8B/%E5%8A%A0%E7%8F%AD%E8%B4%B9%E6%80%8E%E4%B9%88%E7%AE%97/"},{"content":"事实上，法律上有专门的几个名词，用来定义这样的行为，我们逐个来看。 第一个概念叫做商业信誉，比较好理解，是指企业在商业上获得的正面的社会评价，","lvl0":"商品信誉相关","lvl1":["法律"],"lvl2":"摘要","objectID":"f5de8596b3bf056fc5365f5437c0b49b","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/05.%E6%B3%95%E5%BE%8B/%E5%95%86%E5%93%81%E4%BF%A1%E8%AA%89%E7%9B%B8%E5%85%B3/"},{"content":"小白是一家 P2P 公司的 PHP 程序员，主要负责网页工作，为公司宣传、招揽客户。然而两个月前，公司的资金链断裂，高达上亿的资金迟迟不能到位，濒临破产。两","lvl0":"什么是非法集资","lvl1":["法律"],"lvl2":"摘要","objectID":"ef79f58e8128494d9cfbd40bc6c1bae5","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/05.%E6%B3%95%E5%BE%8B/%E9%9D%9E%E6%B3%95%E9%9B%86%E8%B5%84/"},{"content":"非国家工作人员受贿罪 在过去，这个罪一直叫作“公司、企业人员受贿罪”，后来修改成了“非国家工作人员受贿罪”。名称上的变动，可以看出，新罪名针对","lvl0":"受贿法律问题","lvl1":["法律"],"lvl2":"摘要","objectID":"4756992867c3d15fc3427c992e391860","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/05.%E6%B3%95%E5%BE%8B/%E5%8F%97%E8%B4%BF%E7%9A%84%E6%B3%95%E5%BE%8B%E9%97%AE%E9%A2%98/"},{"content":"第八问：中级法院作出二审民事判决后，我对结果仍然不服，还能再继续起诉吗？应该如何维权？ 老周答：我国法院审理普通程序的案件，实行的是两审终审制","lvl0":"诉讼的注意点","lvl1":["法律"],"lvl2":"摘要","objectID":"a391b45db393a8872f118bdc8b14abff","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/05.%E6%B3%95%E5%BE%8B/%E8%AF%89%E8%AE%BC%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"},{"content":"前不久某鹅厂 23 岁安全工程师的新闻，想必你不会陌生。年轻的工程师，因为对酒店的 Wi-Fi 系统顺手一测，又顺手一发给传播了出去，就被新加坡安全局给抓了。","lvl0":"网络安全问题","lvl1":["法律"],"lvl2":"摘要","objectID":"80f73f2f43428111f343d1352eeabe14","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/05.%E6%B3%95%E5%BE%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"content":"说到这个结构，就不得不提一下安卓的几大结构吧主要包括 MVC、MVP、MVVM 这三大结构 MVC结构 Model ：实体模型、数据的获取、存储等等 View ：Act","lvl0":"MVVM架构","lvl1":["程序语言","Android相关"],"lvl2":"摘要","objectID":"70243a10042ef5289c3def019fd917ce","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/05.android%E7%9B%B8%E5%85%B3/01.mvvm%E6%9E%B6%E6%9E%84/"},{"content":"Java核心技术 卷一 基本数据结构 java break可以带标签 大数值可以使用bigInteger和bigDecimal for each使用 1 2 3 for (int a:new int[]{1,2,3}){ System.out.println(a);","lvl0":"Java书籍学习笔记","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"7742bfa91e03a9819d1f4a8995305206","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/13.java%E4%B9%A6%E7%B1%8D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"content":"对象图有几种 UML大科普：一文梳理清 14种 UML图！ (yinxiang.com) UML图分为结构图和行为图。 结构图分为类图、轮廓图、组件图、组合结构图、对象图、部署图","lvl0":"面试问题","lvl1":["基础学科","软件工程"],"lvl2":"摘要","objectID":"9c2a56b13db79c7f3d6a5b031a397973","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/03.%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/01.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"},{"content":"https中间人攻击 如何防止请求被篡改 使用https来进行请求（这点我居然没想到。。） 设置客户端白名单，客户端所有请求，请求到代理服务器(n","lvl0":"网络安全","lvl1":["其他","安全相关"],"lvl2":"摘要","objectID":"638dd4c6e6c75d3300f7bd71579d8875","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/04.%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/01.%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"content":"跨域问题怎么处理 通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx","lvl0":"前端","lvl1":["程序语言","JavaScript和HTML"],"lvl2":"摘要","objectID":"fe576ca02c3a4f211aee55272d479cbf","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/04.javascript%E5%92%8Chtml/03.%E5%89%8D%E7%AB%AF/"},{"content":"优化相关 怎么优化界面，让用户体验更好 减少 HTTP 请求 使用 HTTP2 使用服务端渲染 客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。","lvl0":"HTML","lvl1":["程序语言","JavaScript和HTML"],"lvl2":"摘要","objectID":"7a4e74801f80d4af04bba5c5a1db0f78","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/04.javascript%E5%92%8Chtml/02.html/"},{"content":"JavaScript事件机制 DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 事件捕获（event capt","lvl0":"JavaScript","lvl1":["程序语言","JavaScript"],"lvl2":"摘要","objectID":"918696433458f96a06816fe08e19f06b","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/04.javascript%E5%92%8Chtml/01.javascript/"},{"content":"this指针是干嘛的 其作用就是指向成员函数所作用的对象， 所以非静态成员函数中可以直接使用 this 来代表指向该函数作用的对象的指针。 静态成员函数是不","lvl0":"面试常问问题","lvl1":["程序语言","CC++语言"],"lvl2":"摘要","objectID":"65fe0a82ed1bfac27d311461ff8b6bc3","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/03.cc++%E8%AF%AD%E8%A8%80/02.%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98/"},{"content":"64匹马，8个赛道，找出跑得最快的4匹马 全部马分为8组，每组8匹，每组各跑一次，然后淘汰掉每组的后四名，如下图（需要比赛8场） 第一步 因为我们","lvl0":"面试常问","lvl1":["其他","智力题"],"lvl2":"摘要","objectID":"6e196ddeccd8134b189cac4c6e2a4791","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/01.%E6%99%BA%E5%8A%9B%E9%A2%98/02.%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE/"},{"content":"04. Hook规则 Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。我们提供了一个 linter 插件来强制执行这些规则： 只在最顶层使用 Hook 不要在循环，条件或嵌","lvl0":"Hook规则","lvl1":["《React》笔记","Hook"],"lvl2":"摘要","objectID":"87efe21b0380a831a93a8c315f3e8f57","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/03.hook/04.hook%E8%A7%84%E5%88%99/"},{"content":"03. 使用Effect Hook（副作用钩子） 如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount(挂载完成)，com","lvl0":"使用Effect Hook","lvl1":["《React》笔记","Hook"],"lvl2":"摘要","objectID":"aa107ab2a942f582bc76991bde305452","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/03.hook/03.%E4%BD%BF%E7%94%A8effect-hook/"},{"content":"02. 使用State Hook 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import React, { useState } from \u0026#39;react\u0026#39;; function Example() { // 声明一个叫 \u0026#34;count\u0026#34; 的 state 变量 const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Click me \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 我","lvl0":"使用State Hook","lvl1":["《React》笔记","Hook"],"lvl2":"摘要","objectID":"42162012e8a9782649d53d4573feb5b5","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/03.hook/02.%E4%BD%BF%E7%94%A8state-hook/"},{"content":"05. 自定义 Hook 通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。 目前为止，在 React 中有两种流行的方式来共享组件之间的状态逻辑: render props 和高阶组件，","lvl0":"自定义 Hook","lvl1":["《React》笔记","Hook"],"lvl2":"摘要","objectID":"d1534a69bce2c7d515f593a7c99fb06e","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/03.hook/05.%E8%87%AA%E5%AE%9A%E4%B9%89-hook/"},{"content":"常用操作命令 数据库操作命令 1 2 3 4 5 6 7 8 9 10 11 12 13 # 查看数据库 show dbs; # 切换数据库（如果没有对应的数据库则创建） use 数据库名; # 创建集合 db.c","lvl0":"常用命令","lvl1":["数据库","MongoDB"],"lvl2":"摘要","objectID":"3aa49fafc238caff1e69e22d805d6cfa","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.mongodb/6.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"content":"MongoDB体系结构 MongoDB的体系结构如下所示：磁盘文件经过加载之后后形成 MongoDB 实例，一个 MongoDB 实例中可以存放多个数据库（图中的MongoD","lvl0":"体系和架构","lvl1":["数据库","MongoDB"],"lvl2":"摘要","objectID":"9ddcd5c6c2a1f5b6dc80550e96c723f4","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.mongodb/5.%E4%BD%93%E7%B3%BB%E5%92%8C%E6%9E%B6%E6%9E%84/"},{"content":"MongoDB集群 MongoDB有三种集群的搭建方式 Replica Set 副本集 Sharding 切片 Master-Slaver 主从（不推荐使用） 其中，Sharding集群也是三种集群中最复杂的。副","lvl0":"分布式和集群","lvl1":["数据库","MongoDB"],"lvl2":"摘要","objectID":"14699cf53d7fecd8956cf9f271fe6c1a","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.mongodb/4.%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E9%9B%86%E7%BE%A4/"},{"content":"MongoDB也是有索引的 索引是对数据库一列或多列值进行排序的存储结构，底层一般是一种树状结构，没有索引查询会进行全表扫描，数据量大的时候会","lvl0":"索引","lvl1":["数据库","MongoDB"],"lvl2":"摘要","objectID":"86f622fe749fb14bd28c9ea760da3ae4","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.mongodb/3.%E7%B4%A2%E5%BC%95/"},{"content":"存储引擎介绍 MongoDB支持的引擎有：WiredTiger，MMAPv1和In-Memory。 从MongoDB 3.2 版本开始，WiredTig","lvl0":"存储引擎","lvl1":["数据库","MongoDB"],"lvl2":"摘要","objectID":"f841c190189fa26c42599709cf89af70","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.mongodb/2.%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"},{"content":"主要参考下面几个链接 如何设计一个亿级消息量的IM系统 - InfoQ 写作平台 一个海量在线用户即时通讯系统（IM）的完整设计Plus - 云+社区 - 腾讯云 (tencent.com) .","lvl0":"设计一个IM系统","lvl1":["其他","业务问题"],"lvl2":"摘要","objectID":"86f67efcc5d344d6139f17a3744b74f5","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/02.%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98/3.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAim%E7%B3%BB%E7%BB%9F/"},{"content":"可以参考下面这几个 如何设计并实现一个db连接池？ (juejin.cn)","lvl0":"设计一个数据库连接池","lvl1":["其他","业务问题"],"lvl2":"摘要","objectID":"e5e3156874d3c7d66e905a5a2119367f","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/02.%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98/4.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"content":"Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分","lvl0":"JWT","lvl1":["其他","一些技术"],"lvl2":"摘要","objectID":"fef8220f959fe20e97618c00dd201861","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/03.%E4%B8%80%E4%BA%9B%E6%8A%80%E6%9C%AF/1.jwt/"},{"content":"MongoDB是由哪种语言写的 MongoDB用c++编写的，流行的开源数据库MySQL也是用C++开发的。C++1983年发行是一种使用广泛","lvl0":"面试问题汇总","lvl1":["数据库","MongoDB"],"lvl2":"摘要","objectID":"f521c4e3a1e65c8a261b1b2304657cba","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/03.mongodb/1.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"},{"content":"内存管理 什么是缓冲区溢出？有什么危害？其原因是什么？ 缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据","lvl0":"面试问题整理","lvl1":["基础学科","操作系统"],"lvl2":"摘要","objectID":"54e7600546e9562c101e8e24c027e9ab","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"},{"content":"TLS是啥 SSL/TLS协议其实就是一个安全通信的协议，https采用的就是这个协议来实现安全传输，这个地方主要会问你https的工作原理 TLS","lvl0":"安全相关","lvl1":["基础学科","计算机网络"],"lvl2":"摘要","objectID":"77c0ead66813ceb572f548822692bdba","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"},{"content":"01. Hook概述 Hook可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 什么是 Hook? Hook 是一个特殊的函数，可以让你在函数组件里“钩入” React state 及 生命周","lvl0":"Hook概述","lvl1":["《React》笔记","Hook"],"lvl2":"摘要","objectID":"4722aea6c237b6a0778e61fd4d1e9475","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/03.hook/01.hook%E6%A6%82%E8%BF%B0/"},{"content":"","lvl0":"面试题","lvl1":["数据库","Redis"],"lvl2":"摘要","objectID":"497a476e4276f001284226fb3b15898b","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.redis/7.%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"content":"引用类型有哪些？有什么区别？ 引用类型主要分为强软弱虚四种： 强引用指的就是代码中普遍存在的赋值方式，比如A a = new A()这种。强引用关联的对象，","lvl0":"其他","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"f3104f4bde24c27c98106c1ad2a08a8a","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/12.%E5%85%B6%E4%BB%96/"},{"content":"知乎上就有好多现成的例子，我就拿敖丙的来举例吧 秒杀系统会遇到的几个问题 高并发 超卖 恶意请求 链接暴露 暴露了请求地址，被人恶意请求 数据库 请求太多，","lvl0":"秒杀系统设计","lvl1":["其他","业务问题"],"lvl2":"摘要","objectID":"159e42300de8ceaab73c2818f2ec8293","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/02.%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98/2.%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"content":"这个其实可以使用事务来实现，比如我们可以用MySQL，抢红包时先开启事务，然后加上行锁，修改完毕后我们提交事务，释放行锁 或者我们可以使用Re","lvl0":"设计一个抢红包功能","lvl1":["其他","业务问题"],"lvl2":"摘要","objectID":"33966c25bee9964bbf76db842240e237","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/02.%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98/1.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%8A%A2%E7%BA%A2%E5%8C%85%E5%8A%9F%E8%83%BD/"},{"content":"下图是MySQL底层的一个简单的概括图 日志部分 主要就是这部分了，下面简单介绍一下mysql的三种日志 三种日志 bin log 主要记录所有数据库表结构变更","lvl0":"MySQL底层","lvl1":["数据库","MySQL"],"lvl2":"摘要","objectID":"863498d67f7f24927df3bbcab5cdf389","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/01.mysql/9.mysql%E5%BA%95%E5%B1%82/"},{"content":"案例演示 本节内容根据官方文档的 教程 编写。 在线demo 案例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40","lvl0":"案例演示","lvl1":["《React》笔记","案例演示"],"lvl2":"摘要","objectID":"5ef687cfeef9fb3b7eb970a9f26d46c8","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/04.%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA/01.%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA/"},{"content":"11.React哲学（编写一个复杂组件的原则） React 最棒的部分之一是引导我们思考如何构建一个应用。在这篇文档中，我们将会通过 React 构建一个可搜索的产","lvl0":"React哲学","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"883c7b617c10d59e814f74d38f99a276","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/11.react%E5%93%B2%E5%AD%A6/"},{"content":"10.组合vs继承 React 有十分强大的组合模式。我们推荐使用组合而非继承来实现组件间的代码重用。 包含关系 (组件组合) 有些组件无法提前知晓它们子组件","lvl0":"组合vs继承","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"78b051d1a99e1cc1d508e2b5d69d0926","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/10.%E7%BB%84%E5%90%88vs%E7%BB%A7%E6%89%BF/"},{"content":"09. 状态提升 (共享状态) 通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。 在 React 中，将多个组件中需要共享的","lvl0":"状态提升 (共享状态)","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"3dd29b171552fd50117462b6d35c4d73","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/09.%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87/"},{"content":"","lvl0":"《React》笔记","lvl1":null,"lvl2":"摘要","objectID":"df363b823ad4a743d6d96a32d18ba9d5","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/02.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/25.react%E7%AC%94%E8%AE%B0/"},{"content":"01.高级指引","lvl0":"高级指引","lvl1":["《React》笔记","高级指引"],"lvl2":"摘要","objectID":"6d01f0a9960c1ef25dc9e3c81c3412f1","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/02.%E9%AB%98%E7%BA%A7%E6%8C%87%E5%BC%95/01.%E9%AB%98%E7%BA%A7%E6%8C%87%E5%BC%95/"},{"content":"工人分金条 分蛋糕 过桥问题 黑白帽子 首先就是第一次如果都是白色，那么自己肯定是黑色的。但是没有声音，所以就可以肯定至少有两顶黑帽子，如果有个人发","lvl0":"世界500强的智力题","lvl1":["其他","智力题"],"lvl2":"摘要","objectID":"142ea12bc31c630ac5a6c123ca425bf2","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/08.%E5%85%B6%E4%BB%96/01.%E6%99%BA%E5%8A%9B%E9%A2%98/01.%E4%B8%96%E7%95%8C500%E5%BC%BA%E7%9A%84%E6%99%BA%E5%8A%9B%E9%A2%98/"},{"content":"01. JSX简介 什么是JSX？ 1 const element = \u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt;; 以类似模板语法的方式描述UI的一种语法。它是JS的语法糖，本质上也是JS。可以在其中使用变量或表达式、","lvl0":"JSX简介","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"03dab40a09b8682557067019ccd2578d","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/01.jsx%E7%AE%80%E4%BB%8B/"},{"content":"04. State \u0026amp; 生命周期 State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件. State类似于vue中的data选项 将函数组件转换成 class 组件 在没有useS","lvl0":"State\u0026生命周期","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"7804598aadb5902e3ad7c942726604e4","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/04.state%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"content":"08. 表单 受控组件（双向数据绑定） 在 HTML 中，表单元素（如\u0026lt;input\u0026gt;、 \u0026lt;textarea\u0026gt; 和 \u0026lt;select\u0026gt;）通常自己维护 state，并根","lvl0":"表单","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"c53494f10d212f9692b6c4673efc249b","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/08.%E8%A1%A8%E5%8D%95/"},{"content":"07. 列表 \u0026amp; Key 如下代码，我们使用 map() 函数让数组中的每一项变双倍，然后我们得到了一个新的列表 doubled 并打印出来： 1 2 3 const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((number) =\u0026gt; number * 2); console.log(doubled); 在","lvl0":"列表\u0026Key","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"204191ae2c71a56367eddea01af6437e","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/07.%E5%88%97%E8%A1%A8key/"},{"content":"05. 事件处理 与传统HTML绑定事件的区别 传统的 HTML： 1 2 3 \u0026lt;button onclick=\u0026#34;activateLasers()\u0026#34;\u0026gt; Activate Lasers \u0026lt;/button\u0026gt; 在 React 中略微不同： 1 2 3 4 // 1.事件名为小驼峰； 2.传入函数以大括号包裹","lvl0":"事件处理","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"32056cc773497a6904041dd94741c149","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/05.%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"},{"content":"06. 条件渲染 React 中的条件渲染和 JavaScript 中的一样，使用 JavaScript 运算符 if 或者条件运算符去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI。 观察这两个组件: 1","lvl0":"条件渲染","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"e25436f7e5610a3fae8372c5d266fdf5","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/06.%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"},{"content":"02. 元素渲染 元素是构成 React 应用的最小砖块，描述了你在屏幕上想看到的内容。 1 const element = \u0026lt;h1\u0026gt;Hello, world\u0026lt;/h1\u0026gt;; 与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象","lvl0":"元素渲染","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"51d3610a152433042aca641b734632af","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/02.%E5%85%83%E7%B4%A0%E6%B8%B2%E6%9F%93/"},{"content":"03. 组件 \u0026amp; Props 函数组件与 class 组件 1.函数组件 1 2 3 function Welcome(props){ return \u0026lt;h1\u0026gt;Hello, {props.name}\u0026lt;/h1\u0026gt; } 该函数是一个有效的React组件。接收唯一带有数据的props参数，并返回一个Rea","lvl0":"组件\u0026Props","lvl1":["《React》笔记","核心概念"],"lvl2":"摘要","objectID":"9c3374514c65fb8cac3c6cdb975d76bb","tags":["React"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/12.react%E7%AC%94%E8%AE%B0/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/03.%E7%BB%84%E4%BB%B6props/"},{"content":"操作系统相关 冯诺伊曼体系 该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是中央处理器（CPU）、内存、输入设备、输出","lvl0":"其他","lvl1":["基础学科","操作系统"],"lvl2":"摘要","objectID":"c3ef85a4691a7ea887cb2f9c1741213a","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E5%85%B6%E4%BB%96/"},{"content":"同学的一次面试 内存溢出的两种问题及原因 java.lang.OutOfMemoryError 方法区主要存储类的元信息，实现在元数据区。当JVM发现元数据区没有足够的空间分配给加载的类时，抛出该","lvl0":"面试题","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"04b85235aeea490b65dfab4433af4488","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/11.%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"content":"不知道从哪找的 浏览器禁用 Cookie怎么保存状态 此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是","lvl0":"高频面试题总结","lvl1":["基础学科","计算机网络"],"lvl2":"摘要","objectID":"ab21a72105c832d970695908b1d14200","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"},{"content":"不知道从哪里抄的 如何查看表格定义的所有索引 SHOW INDEX FROM \u0026lt;tablename\u0026gt;; LIKE 声明中的％和 _ 是什么意思？ ％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。 如何在 Unix 和 MySQL","lvl0":"高频面试题","lvl1":["数据库","MySQL"],"lvl2":"摘要","objectID":"4207451b758e8b52742e11a2116225fb","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/01.mysql/8.%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"content":"细说指针 让你不再害怕指针——C指针详解(经典,非常详细)_程序老兵的博客-CSDN博客_c指针详解经典非常详细 1 2 3 4 5 6 7 8 9 int p; //这是","lvl0":"指针问题","lvl1":["程序语言","C语言"],"lvl2":"摘要","objectID":"6e145cf113b4cdb8c5e2520a68e234fe","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/03.cc++%E8%AF%AD%E8%A8%80/01.%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/"},{"content":"主从复制 将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数","lvl0":"分布式和备份","lvl1":["数据库","MySQL"],"lvl2":"摘要","objectID":"f67820236e012ff76693ce73143a2bee","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/01.mysql/7.%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%A4%87%E4%BB%BD/"},{"content":"Linux IO模式 linux有下面五种网络模式 阻塞 I/O（blocking IO） 默认socket就是阻塞IO，当用户进程调用了recvfrom这个系","lvl0":"IO管理,linuxIO模式","lvl1":["基础学科","操作系统"],"lvl2":"摘要","objectID":"6c23feb86526044662447fee2cbbce92","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.io%E7%AE%A1%E7%90%86/"},{"content":"CPU cache结构和缓存一致性（MESI协议） 在多核CPU中，内存中的数据会在多个核心中存在数据副本，某一个核心发生修改操作，就产生了数据不一","lvl0":"互斥和同步","lvl1":["基础学科","操作系统"],"lvl2":"摘要","objectID":"5d89f1e81287cc2411cca957f63f3d85","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5/"},{"content":"基本概念 进程和线程的区别 进程：进程是系统进行资源分配和调度的一个独立单位，是系统中的并发执行的单位 线程：线程是进程的一个实体，也是 CPU 调度和分","lvl0":"进程和线程","lvl1":["基础学科","操作系统"],"lvl2":"摘要","objectID":"e48cdaaa157fba96ede3045d7c3f0d99","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"},{"content":"基本概念 内存分页和内存分段 内存分页分为一个页号还有一个偏移量，我们通过页号查找页表，找出对应地址，然后加上偏移量就可以得到最终地址 内存分段的","lvl0":"内存管理","lvl1":["基础学科","操作系统"],"lvl2":"摘要","objectID":"61c1168a62d9d8792135fe070ac38999","tags":["操作系统"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"content":"基本概念 产生死锁的原因 根本原因 就是系统能够提供的资源个数比要求该资源的进程数要少 基本原因 资源竞争和进程推进顺序不合理 产生死锁必要条件 互斥 一个","lvl0":"死锁和饥饿","lvl1":["基础学科","操作系统"],"lvl2":"摘要","objectID":"2416e09fb9689bfbc6292fa51d6c253e","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/"},{"content":"七层模型 五层模型 网络协议三要素 语法：即数据与控制信息的结构或格式。 语义：即需要发出何种控制信息，完成何种动作以及做出何种响应。 同步：即事件实","lvl0":"体系结构","lvl1":["基础学科","计算机网络"],"lvl2":"摘要","objectID":"586d4036f982304b93ac6c27d0f7be71","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"content":"ARP协议和ARP攻击 arp 协议的全称 arp协议： address resolution protocol , 地址解析协议 resolve : 解析的意思 ARP协议完成了IP地址与物理地址的映射。每一个主机都设有一","lvl0":"网络层(IP,ICMP,ARP)","lvl1":["基础学科","计算机网络"],"lvl2":"摘要","objectID":"c7519a7a5e195220a00345237267f13a","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82ipicmparp/"},{"content":"HTTP协议特点 HTTP和HTTPS的区别 端口不同：HTTP使用的是80端口，HTTPS使用443端口； HTTP认证机制，更加安全； HTTP","lvl0":"应用层(HTTP,SMTP)","lvl1":["基础学科","计算机网络"],"lvl2":"摘要","objectID":"7b30b21a4bbba925859ae0738717309b","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82httpsmtp/"},{"content":"硬件层分为物理层和数据链路层 三种通讯方式 通信的三种基本方式：单工、半双工、双工 物理层几大特性 （1） 机械特性：指明接口所用接线器的形状和尺寸、","lvl0":"硬件层","lvl1":["基础学科","计算机网络"],"lvl2":"摘要","objectID":"590c29baef5ce27410777ff262f53b48","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%A1%AC%E4%BB%B6%E5%B1%82/"},{"content":"TCP的三次握手 问题1 TCP可以建立两次握手嘛 不可以。有两个原因：首先，可能会出现已失效的连接请求报文段又传到了服务器端。 其次，两次握手无法","lvl0":"运输层(TCP,UDP)","lvl1":["基础学科","计算机网络"],"lvl2":"摘要","objectID":"bb7db641cb2d50c81847c1df31166f67","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/03.%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E8%BF%90%E8%BE%93%E5%B1%82tcpudp/"},{"content":"SQL语句分为哪几类 数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER 主要为以上操作 即对逻辑结构等有操作的，","lvl0":"SQL语句及优化","lvl1":["数据库","MySQL"],"lvl2":"摘要","objectID":"05379127cad14ec0866c2afa2f86ae24","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/01.mysql/6.sql%E8%AF%AD%E5%8F%A5%E5%8F%8A%E4%BC%98%E5%8C%96/"},{"content":"缓存雪崩 Redis中大批量key在同一时间同时失效导致所有请求都打到了MySQL。而MySQL扛不住导致大面积崩塌 解决方案 缓存数据的过期时间","lvl0":"常见问题","lvl1":["数据库","NoSQL","Redis"],"lvl2":"摘要","objectID":"04990384280fbf43d07e01da9a0f28d3","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.redis/4.%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"content":"包括 RDB 和 AOF 两种机制，下面分别进行说明 RDB RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。更适合做冷备。 优点： 压缩后的二进制文，适用于备份、全量","lvl0":"持久化","lvl1":["数据库","NoSQL","Redis"],"lvl2":"摘要","objectID":"e78274c510a79066c1927173b6e8670b","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.redis/2.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"content":"分布式锁 在日常情况下在进程或线程中我们可以使用 synchronized 、Lock 实现并发编程，但是我， 如何在分布式集群下使用呢？可以使用 Redisson ， Zookeeper ，Redis本身 分布","lvl0":"分布式锁，过期策略，淘汰规则","lvl1":["数据库","NoSQL","Redis"],"lvl2":"摘要","objectID":"48ca53cf7452e5045af20a9cf4d00746","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.redis/5.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%B7%98%E6%B1%B0%E8%A7%84%E5%88%99/"},{"content":"Redis有下面四种部署方式 模式 优点 缺点 单机版 架构简单，部署方便 机器故障、容量瓶颈、QPS瓶颈 主从复制 高可靠性，读写分离 故障恢复复杂，主库的","lvl0":"集群和限流","lvl1":["数据库","NoSQL","Redis"],"lvl2":"摘要","objectID":"ebd5048fb55706f4d61564def7002ad7","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.redis/6.%E9%9B%86%E7%BE%A4%E5%92%8C%E9%99%90%E6%B5%81/"},{"content":"概念 事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻","lvl0":"事务和锁","lvl1":["数据库","MySQL"],"lvl2":"摘要","objectID":"87d229bb111e4442bce71c79b6cfecb3","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/01.mysql/4.%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/"},{"content":"什么是视图 所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以","lvl0":"视图，存储过程，函数，触发器","lvl1":["数据库","MySQL"],"lvl2":"摘要","objectID":"a4564026766d7b1ad2166c0d12d05576","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/01.mysql/5.%E8%A7%86%E5%9B%BE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E8%A7%A6%E5%8F%91%E5%99%A8/"},{"content":"数据库三大范式 第一范式（属性不可再分） 如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。 第二范式（每个非主属性","lvl0":"数据库基础","lvl1":["数据库","MySQL"],"lvl2":"摘要","objectID":"c2dbd0c69801eef9f3f8475de28cd06c","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/01.mysql/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"content":"本文参考：硬核Redis总结，看这篇就够了！ (qq.com) 8大基本数据类型 String 适用于简单key-value存储、setnx key value实现分布式锁、计数器","lvl0":"数据类型","lvl1":["数据库","NoSQL","Redis"],"lvl2":"摘要","objectID":"365774410aa7e01ce477a852281b7c79","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.redis/1.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"content":"概念 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。 索引是一种数据结构。数","lvl0":"索引","lvl1":["数据库","MySQL"],"lvl2":"摘要","objectID":"5f29c6176ae9259ac422fc6c1632b87e","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/01.mysql/3.%E7%B4%A2%E5%BC%95/"},{"content":"常考的主要分为InnoDB，MyISAM 主要区别 InnoDB引擎的4大特性 插入缓冲（insert buffer) 二次写(double write) 自适应哈希索引(ah","lvl0":"引擎","lvl1":["数据库","MySQL"],"lvl2":"摘要","objectID":"e8b5a02a871defeff2a86a771df18935","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/01.mysql/2.%E5%BC%95%E6%93%8E/"},{"content":"为什么Redis速度那么快 基于内存实现 数据结构高效，底层多种数据结构支持不同的数据类型，比如HyperLogLog它连2个字节都不想浪费 提供","lvl0":"原理","lvl1":["数据库","NoSQL","Redis"],"lvl2":"摘要","objectID":"b440891e3c1b8b1211b7346046842c82","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.redis/3.%E5%8E%9F%E7%90%86/"},{"content":"这里主要涉及到IO多路复用 基本概念介绍 BIO 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理","lvl0":"IO NIO框架","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"f796aee5d22483ef63eee254320bb1eb","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/5.io-nio%E6%A1%86%E6%9E%B6/"},{"content":"java语言的特性 Lambda表达式和函数式接口 最简单的lambda表达式如下 1 Arrays.asList( \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;d\u0026#34; ).forEach( e -\u0026gt; System.out.println( e ) ); 当然，为了显式说明某个接口是函数式接口","lvl0":"java8特性","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"3e10901570b6f1943bff28bbbad39112","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/10.java8%E7%89%B9%E6%80%A7/"},{"content":"return和finally的执行顺序 finally语句在return语句执行之后return返回之前执行的，所以我们先执行return的语","lvl0":"java基础","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"431e56e7b28cbdaa0fe48522541463b7","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/1.java%E5%9F%BA%E7%A1%80/"},{"content":"JVM内存模型 这里主要还是会问一些Java的内存模型，1.8之前和之后的内存模型是不一样的 简单说一下每个部分是干嘛的吧 程序计数器 用于记录程序","lvl0":"JVM模型","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"bb30d988577c44c74b52fcc8bbdc2c21","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/6.jvm%E6%A8%A1%E5%9E%8B/"},{"content":"并发框架，其实也叫 JUC 即 java.util.concurrent 包，分为（锁框架、原子类框架、同步器框架、集合框架、执行器框架） 线程创建方式 继承Thread类重写run方法 1 2 3 4","lvl0":"并发框架(JUC)","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"2867b772b03c1be2332167e1f3f88a0e","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/4.%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6juc/"},{"content":"","lvl0":"参数调优","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"b015c77a041098e7b745e59def8e32ed","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/9.%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"},{"content":"for和range for循环的三种用法 for range用于遍历切片，数组或者map 几个用法 使用 for range a {} 遍历数组和切片，不关心索引和数据的情况； 使","lvl0":"常用关键字","lvl1":["程序语言","Go"],"lvl2":"摘要","objectID":"4cfa6d1171d7dabc9a4a00a7bf1d7abf","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/4.%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"},{"content":"集合框架也可以叫容器。（集合是用于存储数据的容器） 常问的有下面几个 ArrayList LinkList HashSet TreeSet HashMap List(对付顺序的好帮手)： 存储的元素是有序的、可重复的。 Se","lvl0":"集合框架","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"13c7fcd40cb3081ab9d269f7c62843b4","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/3.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"},{"content":"判断对象是否是垃圾 引用计数算法：判断对象的引用数量 每引用一次就+1，当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的","lvl0":"垃圾回收","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"b856607425542441fa18b09e4c327559","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"content":"类加载流程 只需要记住下面这5个阶段就行了 参考：JVM 基础 - Java 类加载机制 | Java 全栈知识体系 (pdai.tech) 下面简单介绍一下每个部分做了啥 加载 首先获取二进制流，","lvl0":"类加载机制","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"0b45b52ba484dd9703bb1ffc74d99880","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/7.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"content":"这个部分主要以面试题为主 京东面试题 是equals而不是equal，单词错了 类和对象 面向对象和面向过程的区别 面向过程 ：面向过程性能比面向对象高","lvl0":"面向对象","lvl1":["程序语言","JAVA"],"lvl2":"摘要","objectID":"bdac9bb0a38ab681079660bc1721fdbc","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/02.java/2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"content":"数据类型 数据类型占用的字节数 整数 int 64位操作系统默认为int64,32位操作系统为int32,但是类型检查时时int int8 (byte 1字节) int16 (short 2字节)","lvl0":"数据结构","lvl1":["程序语言","Go"],"lvl2":"摘要","objectID":"ad2d56a03994734b37aab603ac8649ea","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"content":"函数调用 这里面涉及的东西其实挺深的，所以等我后面又时间再去研究 Go 中函数传参仅有值传递一种方式； slice、map、channel都是引用类型","lvl0":"语言基础","lvl1":["程序语言","Go"],"lvl2":"摘要","objectID":"9986ccd18bf5e95c2b931b1ea35123c9","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/01.%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/01.go/3.%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"content":"JS设计模式总结笔记 开篇：前端工程师的成长论 能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。 所谓“不变的东西”","lvl0":"JS设计模式总结笔记","lvl1":["前端","学习笔记"],"lvl2":"摘要","objectID":"809f1d2a9ade2f6423de5730b714f313","tags":["设计模式"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/02.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/50.js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/"},{"content":"","lvl0":"Git命令思维导图","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"48d056dc9e7c6aaf41316e22869d1492","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/06.git%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"},{"content":"rebase分支合并 说明 以下 v2 是某个需求的开发分支， dev是总的开发分支，v2 是基于dev分支签出的。 当完成v2的开发后，需要把代码合并到d","lvl0":"Git变基合并","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"6b86a6b3c00f7679b6b1579b305a17e0","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/03.git%E5%8F%98%E5%9F%BA%E5%90%88%E5%B9%B6/"},{"content":"Git分支-变基 在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，","lvl0":"Git分支-变基","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"40b6d5fa717de5163e089edf3a6588bc","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/70.git%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA/"},{"content":"Git分支-分支原理 Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许","lvl0":"Git分支-分支原理","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"92cd0ff4e1f7b4a4b6075c6ffb32c027","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/20.git%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86/"},{"content":"Git分支-远程分支 远程引用是对远程仓库的引用（指针），包括分支、标签等等。 远程分支本质上也是一个指针，指向远程地址 查看远程引用列表与信息 1","lvl0":"Git分支-远程分支","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"a2474eea01c6dd733d1fd110484240ff","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/60.git%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/"},{"content":"Git分支的新建与合并-分支操作 文档：Git 分支 - 分支的新建与合并 创建分支并切换 此时有一个需求需要在新的分支iss53上工作： 1 $ git checkout -b iss53 #","lvl0":"Git分支的新建与合并-分支操作","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"3b007d706a920f68582c671e5c8ae38e","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/30.git%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/"},{"content":"Git分支管理-查看分支 查看分支 1 2 3 4 $ git branch iss53 * master # 带星号*表示当前所在分支 testing git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会","lvl0":"Git分支管理-查看分支","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"898e5cbc3b71b459bc15c28797fe98f7","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/40.git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF/"},{"content":"Git分支开发工作流 文档：Git分支开发工作流 长期分支 因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，","lvl0":"Git分支开发工作流","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"1abd5eb7ecb72f1cb26ab0e95ac2a791","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/50.git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"content":"Git工具-查看修订版本 Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。 修订版本","lvl0":"Git工具-查看修订版本","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"fa81530c67939fbd653dc4e6f38b2eb0","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/80.git%E5%B7%A5%E5%85%B7-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC/"},{"content":"Git工具-交互式暂存 本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不","lvl0":"Git工具-交互式暂存","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"25d8c501bd90e2918fd28fc737de443a","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/90.git%E5%B7%A5%E5%85%B7-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98/"},{"content":"Git 工具 - 重写历史 许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件","lvl0":"Git工具-重写历史","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"2510b51cfec6012122221cad58c52977","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/100.git%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2/"},{"content":"Git 工具 - 重置揭密 在继续了解更专业的工具前，我们先探讨一下 Git 的 reset 和 checkout 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来","lvl0":"Git工具-重置揭密","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"c7d5bab15a2befb2c961d03b062c2146","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/110.git%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86/"},{"content":"Git基础与命令 官方文档（中文）：https://git-scm.com/book/zh/v2 本文档是根据官方文档来编写的，以官方文档为准。","lvl0":"Git基础与命令","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"493aecd17f1e29215ef4052e1f069693","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/10.git%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%91%BD%E4%BB%A4/"},{"content":"常用Git命令清单 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单","lvl0":"常用Git命令清单","lvl1":["《Git》学习笔记"],"lvl2":"摘要","objectID":"d939ee926e27e098c5f1b0280a5436b5","tags":["Git"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/08.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/00.%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"},{"content":"","lvl0":"《Git》学习笔记","lvl1":null,"lvl2":"摘要","objectID":"1c818337033ea5b7ab88c2ad278648ca","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/02.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/33.git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"content":"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。 看一本书 → 看一页书 写一篇文章 → 写一句话 跑10公里 → 穿上跑鞋 做100次俯卧撑","lvl0":"2分钟规则","lvl1":["更多","实用技巧"],"lvl2":"摘要","objectID":"1a6bde500f570cc652b7c7517d634b71","tags":["实用技巧","文摘"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/10.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/01.2%E5%88%86%E9%92%9F%E8%A7%84%E5%88%99/"},{"content":"TypeScript 学习笔记 TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。 类型注解 1 2 3 4 5 6 function fn(person: string):void{ // 参数类型是字符串，没有返回值 ///... } fn(\u0026#39;str\u0026#39;) // 如传递参数非","lvl0":"TypeScript笔记","lvl1":["前端","学习笔记"],"lvl2":"摘要","objectID":"14886dae587bc93eb192373ce7e37a72","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/02.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/35.typescript%E7%AC%94%E8%AE%B0/"},{"content":"Flex 布局教程：语法篇 http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html CSS Grid 网格布局教程 http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html 只要一行代码，实现五种 CSS 经典布局 http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html 空间居中布局 不管容器的大小，项目总是占据中心点 并列式布局 多个项目并列","lvl0":"CSS教程和技巧收藏","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"d3573db34e4796a32299693f3742bfee","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/00.css%E6%95%99%E7%A8%8B%E5%92%8C%E6%8A%80%E5%B7%A7%E6%94%B6%E8%97%8F/"},{"content":"Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 Vuex使用过程演示 以vue-cli3新创建出来的项目为例，演示Vuex的使用过程。 创建项目: 1","lvl0":"Vuex","lvl1":["《Vue》笔记","Vuex"],"lvl2":"摘要","objectID":"d788986e510383bd1a6c6a76fc597727","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/10.vuex/01.vuex/"},{"content":"反向拆解让人上瘾的套路，找回自律 当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规\u0026hellip; 某某app发来通知：x","lvl0":"反向拆解让人上瘾的套路，找回自律","lvl1":["更多","心情杂货"],"lvl2":"摘要","objectID":"5a85061b578a2837e5553b453dd4dc11","tags":["心理","自律"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/10.%E5%8F%8D%E5%90%91%E6%8B%86%E8%A7%A3%E8%AE%A9%E4%BA%BA%E4%B8%8A%E7%98%BE%E7%9A%84%E5%A5%97%E8%B7%AF%E6%89%BE%E5%9B%9E%E8%87%AA%E5%BE%8B/"},{"content":"::: center 康奈尔笔记法 思维导图法 金三角笔记法 曼陀罗九宫格笔记法 记号记录法 六色笔记法 加工笔记法 整理笔记要点1-科学标记重点 整理笔记要点2-修改不涂改","lvl0":"笔记方法","lvl1":["更多","学习"],"lvl2":"摘要","objectID":"a2fc17c0636a9c01e22a53315c653c61","tags":["笔记方法"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/01.%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95/"},{"content":"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事","lvl0":"费曼学习法","lvl1":["更多","学习"],"lvl2":"摘要","objectID":"d69721d20293174fc5ffddaa73ff9f3a","tags":["学习方法"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/00.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/"},{"content":"《JavaScript高级程序设计》笔记 第1章 JavaScript简介 JavaScript诞生于1995年 一个完整的JavaScript由这","lvl0":"《JavaScript高级程序设计》笔记","lvl1":["笔记"],"lvl2":"摘要","objectID":"90103c668d44f570ccef52a06c97020c","tags":["笔记","红宝书"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/02.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05.javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"content":"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提","lvl0":"搜索引擎使用技巧","lvl1":["更多","学习"],"lvl2":"摘要","objectID":"1d9f3ae3c86ed2c6f278305da3beca02","tags":["搜索技巧"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/10.%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"content":"","lvl0":"CSS-function汇总","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"68cbdfd7f6089cf5552186a0f6296687","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/60.css-function%E6%B1%87%E6%80%BB/"},{"content":"个人收藏夹 大佬收藏夹 panjiachen 文档 MDN | MDN-JS标准内置对象 Web技术权威文档 现代JavaScript教程 以最新标准为基准的JS教程 ES5教程 阮一","lvl0":"网站","lvl1":null,"lvl2":"摘要","objectID":"096c22226d32064e48f3e8694c3000ad","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/06.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99/"},{"content":"「css技巧」使用hover和attr()定制悬浮提示-demo See the Pen 【CSS：行为】使用:hover和attr()定制悬浮提示 by xugaoyi (@xugaoyi) on CodePen.","lvl0":"「css技巧」使用hover和attr()定制悬浮提示","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"9d6b8056874101f185acd4ac6a37d110","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/50.css%E6%8A%80%E5%B7%A7%E4%BD%BF%E7%94%A8hover%E5%92%8Cattr%E5%AE%9A%E5%88%B6%E6%82%AC%E6%B5%AE%E6%8F%90%E7%A4%BA/"},{"content":"比typeof运算符更准确的类型判断 不同数据类型的Object.prototype.toString方法返回值如下。 数值：返回[object","lvl0":"比typeof运算符更准确的类型判断","lvl1":["前端","JavaScript文章"],"lvl2":"摘要","objectID":"02a0cbefb005dc51fd90d09f4888804d","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/01.javascript%E6%96%87%E7%AB%A0/100.%E6%AF%94typeof%E8%BF%90%E7%AE%97%E7%AC%A6%E6%9B%B4%E5%87%86%E7%A1%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"},{"content":"npm package.json属性详解 本文转自https://www.cnblogs.com/tzyy/p/5193811.html，作者：TZ","lvl0":"npm packageJson属性详解","lvl1":["技术","技术文档"],"lvl2":"摘要","objectID":"d751e557a419940448afdd77dcd158e9","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/10.npm-packagejson%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/"},{"content":"vdoing主题效果图 PC端 首页 \u0026 目录页△ 文章详情页 \u0026 时间轴页△ 首页个性化大图 首页个性化大图△ 深色模式和阅读模式 深色模式△ 阅读模式△ 移动端 移","lvl0":"vdoing主题效果图","lvl1":null,"lvl2":"摘要","objectID":"41d443250ee3f10e32db2f70e6d817d3","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/10.vdoing%E4%B8%BB%E9%A2%98%E6%95%88%E6%9E%9C%E5%9B%BE/"},{"content":"如何根据系统主题自动响应CSS深色模式 很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇","lvl0":"如何根据系统主题自动响应CSS深色模式","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"28300efc48585f2b5d44f23ba71ce78a","tags":["css"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/45.%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%BB%E9%A2%98%E8%87%AA%E5%8A%A8%E5%93%8D%E5%BA%94css%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F/"},{"content":"水平垂直居中的几种方式-案例 See the Pen 水平垂直居中的几种方式 by xugaoyi (@xugaoyi) on CodePen.","lvl0":"水平垂直居中的几种方式-案例","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"716a181c602f945510803cd5896df847","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/40.%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-%E6%A1%88%E4%BE%8B/"},{"content":"GitHub加速下载项目的方法 国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的","lvl0":"GitHub加速下载项目的方法","lvl1":["技术","GitHub技巧"],"lvl2":"摘要","objectID":"d57c50289fec46a233b22a7ffc0dd4af","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/02.github%E6%8A%80%E5%B7%A7/10.github%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E6%B3%95/"},{"content":"JS获取和修改url参数 获取url参数 1 2 3 4 5 6 7 8 9 10 11 12 /** * 获取url里的参数 * @param arg 参数名 * @returns */ function getURLString(arg) { var reg = new RegExp(\u0026#34;(^|\u0026amp;)\u0026#34; + arg + \u0026#34;=([^\u0026amp;]*)(\u0026amp;|$)\u0026#34;, \u0026#34;i\u0026#34;); var r = window.location.search.substr(1).match(reg); if (r","lvl0":"JS获取和修改url参数","lvl1":["前端","JavaScript文章"],"lvl2":"摘要","objectID":"79cd2b39457146f46b016917a63ce0d7","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/01.javascript%E6%96%87%E7%AB%A0/90.js%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BF%AE%E6%94%B9url%E5%8F%82%E6%95%B0/"},{"content":"防抖与节流函数 防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。 区别在于，防抖函数只会在高频事件结束后n毫秒调用一次","lvl0":"防抖与节流函数","lvl1":["前端","JavaScript文章"],"lvl2":"摘要","objectID":"e01be2cebb937136c3812399f7a3f529","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/01.javascript%E6%96%87%E7%AB%A0/80.%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/"},{"content":"从box-sizing属性入手，了解盒子模型 背景 先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，","lvl0":"从box-sizing属性入手，了解盒子模型","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"14966866ad4fddb6e28193d9fc94b943","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/35.%E4%BB%8Ebox-sizing%E5%B1%9E%E6%80%A7%E5%85%A5%E6%89%8B%E4%BA%86%E8%A7%A3%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"},{"content":"文字在一行或多行时超出显示省略号 一行超出显示省略 1 2 3 overflow: hidden; white-space: nowrap; text-overflow: ellipsis; :::demo [vanilla] 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;html\u0026gt; \u0026lt;div class=\u0026#34;box-42b6\u0026","lvl0":"文字在一行或多行时超出显示省略号","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"958382b3a24e2494e4568ec86b0ac16e","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/30.%E6%96%87%E5%AD%97%E5%9C%A8%E4%B8%80%E8%A1%8C%E6%88%96%E5%A4%9A%E8%A1%8C%E6%97%B6%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7/"},{"content":"将一维数组按指定长度转为二维数组 将一维数组按指定长度转为二维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function pages(arr, len) { const pages = [] arr.forEach((item, index) =\u0026gt; { const page = Math.floor(index / len) if (!pages[page]) { pages[page]","lvl0":"将一维数组按指定长度转为二维数组","lvl1":["前端","JavaScript文章"],"lvl2":"摘要","objectID":"8c9ee9b8b15aeae94d5633a3e957bea1","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/01.javascript%E6%96%87%E7%AB%A0/70.%E5%B0%86%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8C%89%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E8%BD%AC%E4%B8%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"content":"「布局技巧」图片未加载前自动撑开元素高度 在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢","lvl0":"「布局技巧」图片未加载前自动撑开元素高度","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"b4c27bd9a30b75cc3a063767386d9ee9","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/20.%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7%E5%9B%BE%E7%89%87%E6%9C%AA%E5%8A%A0%E8%BD%BD%E5%89%8D%E8%87%AA%E5%8A%A8%E6%92%91%E5%BC%80%E5%85%83%E7%B4%A0%E9%AB%98%E5%BA%A6/"},{"content":"ES5面向对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 //面向对象","lvl0":"ES5面向对象","lvl1":["前端","JavaScript文章"],"lvl2":"摘要","objectID":"fdab650f011dfcf052c54dc0f56691e1","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/01.javascript%E6%96%87%E7%AB%A0/03.es5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"content":"常用meta整理 \u0026lt;meta\u0026gt; 元素 概要 meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内","lvl0":"常用meta整理","lvl1":["页面","HTML"],"lvl2":"摘要","objectID":"8233a77eeb84d47caf4b9685dc3fb68f","tags":["HTML"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/10.html/10.%E5%B8%B8%E7%94%A8meta%E6%95%B4%E7%90%86/"},{"content":"Vue CLi v3.x 创建项目使用记录 官方文档 以下使用的CLi版本是 v3.11.0 vue create 运行以下命令来创建一个新项目 1 vue create hello-world 你会被提示选取一个 preset (预设)。你可以选默认的包","lvl0":"Vue CLi v3 创建项目使用记录","lvl1":["《Vue》笔记","工具"],"lvl2":"摘要","objectID":"a394a612d0d5ecab0986fefc327f2970","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/05.%E5%B7%A5%E5%85%B7/10.vue-cli-v3-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"},{"content":"Mixin混入 基础 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混","lvl0":"Mixin混入","lvl1":["《Vue》笔记","可复用性\u0026组合"],"lvl2":"摘要","objectID":"828cfc91726a0ab0e0b08535903aaa7e","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/04.%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%E7%BB%84%E5%90%88/01.mixin%E6%B7%B7%E5%85%A5/"},{"content":"vue父子组件的生命周期顺序 加载渲染过程 1 父beforeCreate -\u0026gt; 父created-\u0026gt; 父beforeMount-\u0026gt; 子befo","lvl0":"vue父子组件的生命周期顺序","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"41abe1287f0f46f50c6685d57f740dd8","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/90.vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F/"},{"content":"vue中使用Animate.css库 自定义过渡类名 我们可以通过以下 attribute 来自定义过渡类名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 他们的优先级高于普通的类名，这对于 Vue 的","lvl0":"使用animate库","lvl1":["《Vue》笔记","过渡\u0026动画"],"lvl2":"摘要","objectID":"8c3b3a59d67317d884637c5a1dde2a91","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/03.%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/112.%E4%BD%BF%E7%94%A8animate%E5%BA%93/"},{"content":"动态组件与 v-once 指令 动态组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;!--其效果如同下面两行被注释的代码--\u0026gt;","lvl0":"动态组件与 v-once 指令","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"3754a4d3df53eff76459579b749a631b","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/80.%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8E-v-once-%E6%8C%87%E4%BB%A4/"},{"content":"插槽slot API 插槽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;child\u0026gt; \u0026lt;!-- 组件标签 --\u0026gt; \u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt; \u0026lt;/child\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.component(\u0026#39;child\u0026#39;, { // 子组件 template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; }) var vm = new Vue({ el: \u0026#39;#root\u0026#39; }) \u0026lt;/script\u0026gt; 上面代码中，组件标签内的h1","lvl0":"插槽slot","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"99a11a2f3229d58c71ee0036a09e5395","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/75.%E6%8F%92%E6%A7%BDslot/"},{"content":"非父子组件间传值 当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用vuex实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模","lvl0":"非父子组件传值","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"6ee57a63c922b7b93271722639806b94","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/65.%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"},{"content":"自定义事件 API 在组件标签v-on绑定的事件是自定义事件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;child @click=\u0026#34;handleClick\u0026#34;\u0026gt;\u0026lt;/child\u0026gt; \u0026lt;!--这里click是自定义事件--","lvl0":"自定义事件","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"f1c354a519adbf9e5fe551015674d061","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/55.%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/"},{"content":"Prop 验证 与 非 Prop 的 Attribute Prop 验证 API 子组件对父组件传递来的参数进行校验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Vue.component(\u0026#39;my-component\u0026#39;, { props: { // 基础的","lvl0":"Prop 验证 与 非 Prop 的 Attribute","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"aee37fc965bb3282192c37897bca179b","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/52.prop-%E9%AA%8C%E8%AF%81-%E4%B8%8E-%E9%9D%9E-prop-%E7%9A%84-attribute/"},{"content":"使用组件的细节点 解析 DOM 模板时的注意事项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;row\u0026gt;\u0026lt;/row\u0026gt; \u0026lt;row\u0026gt;\u0026lt;/row\u0026gt; \u0026lt;row\u0026gt;\u0026lt;/row\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.component(\u0026#39;row\u0026#39;, { template: \u0026#39;\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;this is a row\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026#39; }) var vm = new Vue({ el: \u0026#39;#root\u0026#39; }) \u0026lt;/script\u0026gt; 上面代码中","lvl0":"使用组件的细节点","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"5ce866017118b9fd15bd2dcab887cfdf","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/36.%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E7%BB%86%E8%8A%82%E7%82%B9/"},{"content":"Mixin JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。 但是，","lvl0":"Mixin","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"ee67724e319d572893f2e17fd5667b04","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/32.mixin/"},{"content":"SIMD 概述 SIMD（发音/sim-dee/）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这","lvl0":"SIMD","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"9e1a848368083c490f8132accce180a1","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/33.simd/"},{"content":"参考链接 官方文件 ECMAScript® 2015 Language Specification: ECMAScript 2015 规格 ECMAScript® 2016 Language Specification: ECMAScript 2016 规格 ECMAScript® 2017 Language Specification","lvl0":"参考链接","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"820f23c4aa28df0d1677df1d7032b55e","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/34.%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5/"},{"content":"函数式编程 JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面","lvl0":"函数式编程","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"06c75a60ab400b74244b5245ccde125a","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/31.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"content":"装饰器 [说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完","lvl0":"装饰器","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"c3559aad5b972af0508d34879e71b807","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/30.%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"content":"最新提案 本章介绍一些尚未进入标准、但很有希望的最新提案。 do 表达式 本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。 1 2 3 4 { let","lvl0":"最新提案","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"1ea3bc0225e2deb15a41f54b2f08f4ad","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/29.%E6%9C%80%E6%96%B0%E6%8F%90%E6%A1%88/"},{"content":"ArrayBuffer ArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（","lvl0":"ArrayBuffer","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"c5d88a38e7f04978fade95f79b5fd43f","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/28.arraybuffer/"},{"content":"async 函数 含义 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 async 函数是什么？一句话，它就是 Generator 函数的语法糖。 前文有一个 Generator 函数，依次读取两个文件。 1 2","lvl0":"async 函数","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"bb4bc4784c98061de1d3d69d7d2ece51","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/20.async-%E5%87%BD%E6%95%B0/"},{"content":"Class 的基本语法 简介 类的由来 JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 1 2 3 4 5 6 7 8 9 10 function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () {","lvl0":"Class 的基本语法","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"079cefbc4ab234d37c1e0b5db74adffc","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/21.class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"content":"Class 的继承 简介 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 1 2 3 4 5 class Point { } class ColorPoint extends Point { } 上面代码","lvl0":"Class 的继承","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"945d7f0bfed20f7f333e07aa91be385e","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/22.class-%E7%9A%84%E7%BB%A7%E6%89%BF/"},{"content":"Generator 函数的异步应用 异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要","lvl0":"Generator 函数的异步应用","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"256770bef009fbd6550a5437be2904c0","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/19.generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8/"},{"content":"Generator 函数的语法 简介 基本概念 Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用","lvl0":"Generator 函数的语法","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"7f4ce86890b3fbbc30f04e8382459b20","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/18.generator-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/"},{"content":"Iterator 和 for\u0026hellip;of 循环 Iterator（遍历器）的概念 JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Ma","lvl0":"Iterator 和 for-of 循环","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"24a08e24f18f930c1c2995315d2f867c","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/17.iterator-%E5%92%8C-for-of-%E5%BE%AA%E7%8E%AF/"},{"content":"let 和 const 命令 let 命令 基本用法 ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效(块级作用","lvl0":"let 和 const 命令","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"8f419eb256b3c2e62dcd3554be9d7ed4","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/02.let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/"},{"content":"Module 的加载实现 上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。 浏览器加载 传统","lvl0":"Module 的加载实现","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"cf32dd5dbd91f396929781f3bfc4f49e","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/24.module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"},{"content":"Module 的语法 概述 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其","lvl0":"Module 的语法","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"be02ff26c2e5a2d407bae2063db5a9f9","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/23.module-%E7%9A%84%E8%AF%AD%E6%B3%95/"},{"content":"Promise 对象 Promise 的含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言","lvl0":"Promise 对象","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"13bae18a00b03b062c2e0de9e3b43d7b","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/16.promise-%E5%AF%B9%E8%B1%A1/"},{"content":"Proxy 概述 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程","lvl0":"Proxy","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"350f3ccc6144e432e79dcf75eecaa6ed","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/14.proxy/"},{"content":"Reflect 概述 Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 （1） **将Obj","lvl0":"Reflect","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"9fb8cd2c920d77ea5eb9825b2ff5dac2","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/15.reflect/"},{"content":"Set 和 Map 数据结构 Set 基本用法 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成 Set","lvl0":"Set 和 Map 数据结构","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"6495c7f59a3a9be8ed399bc4b6199b14","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/13.set-%E5%92%8C-map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"content":"Symbol 概述 ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新","lvl0":"Symbol","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"a7a0bf518819f082e1adbeb02c6d2039","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/12.symbol/"},{"content":"编程风格 本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。 多家公司和组织已经公开了它","lvl0":"编程风格","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"073ae8dd68146b5d90739256f0d1f9b8","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/25.%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"},{"content":"变量的解构赋值 数组的解构赋值 基本用法 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以","lvl0":"变量的解构赋值","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"9dbced91b85bd3c02af11f5a30671d7d","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/03.%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"content":"读懂 ECMAScript 规格 概述 规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。 一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象","lvl0":"读懂 ECMAScript 规格","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"46f4c288b864d9c912d025c7590d9437","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/26.%E8%AF%BB%E6%87%82-ecmascript-%E8%A7%84%E6%A0%BC/"},{"content":"对象的扩展 对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍Object对象的新增方","lvl0":"对象的扩展","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"cd140fd6aea5f16a0837d583d0bc9c30","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/10.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/"},{"content":"对象的新增方法 本章介绍 Object 对象的新增方法。 Object.is() ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，","lvl0":"对象的新增方法","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"897d47a3568e9e542af7fa1b7052e6b2","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/11.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/"},{"content":"函数的扩展 函数参数的默认值 基本用法 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 1 2 3 4 5 6 7 8 function log(x, y) { y = y || \u0026#39;World\u0026#39;; console.log(x, y); } log(\u0026#39;Hello\u0026#39;) // Hello","lvl0":"函数的扩展","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"93d85f1d0bdc1025c2d37ed8175d41cc","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/08.%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"},{"content":"数值的扩展 二进制和八进制表示法 ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 1 2 0b111110111 === 503 // true 0o767 === 503 // true 从","lvl0":"数值的扩展","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"eda8e25eb6b9cf122397841f0076b0ee","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/07.%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/"},{"content":"数组的扩展 扩展运算符 含义 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 1 2 3 4 5 6","lvl0":"数组的扩展","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"8a63716ac320381d94c70833f46e48fb","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/09.%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"},{"content":"异步遍历器 同步遍历器的问题 《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，","lvl0":"异步遍历器","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"dcf5391a9d301c1ffb27f12890beb6df","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/27.%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8/"},{"content":"正则的扩展 RegExp 构造函数 在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag","lvl0":"正则的扩展","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"3096267dd2e314b5168c9890bc65160d","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/06.%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95/"},{"content":"字符串的扩展 本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。 字符的 Unicode 表示法 ES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一","lvl0":"字符串的扩展","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"2e8a3913e507f587a04788f29993a1b7","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"},{"content":"字符串的新增方法 本章介绍字符串对象的新增方法。 String.fromCodePoint() ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法","lvl0":"字符串的新增方法","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"3edf50499f6a26c8ef9cae4f9b4116e4","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/"},{"content":"JS随机打乱数组 1 2 3 4 5 6 7 8 9 10 11 12 13 function shuffle(arr) { // 随机打乱数组 let _arr = arr.slice() // 调用数组副本，不改变原数组 for (let i = 0; i \u0026lt; _arr.length; i++) { let j = getRandomInt(0, i) let t = _arr[i] _arr[i] =","lvl0":"JS随机打乱数组","lvl1":["前端","JavaScript文章"],"lvl2":"摘要","objectID":"c80bac37106b00a15ab88da869d1836b","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/01.javascript%E6%96%87%E7%AB%A0/50.js%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"},{"content":"列表渲染之数组、对象更新检测 数组更新检测API 对象更新检测API 数组更新检测 变异方法 (mutation method) Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会","lvl0":"列表渲染之数组、对象更新检测","lvl1":["《Vue》笔记","基础"],"lvl2":"摘要","objectID":"da86d9a768ad48063343fbf7c5398dcd","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80/35.%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E4%B9%8B%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B/"},{"content":"v-if vs v-show API v-if 根据渲染条件决定是否把元素渲染到DOM页面，而v-show不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显","lvl0":"v-if vs v-show","lvl1":["《Vue》笔记","基础"],"lvl2":"摘要","objectID":"1112c5ae65ed01971bd4af01200a3be7","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80/30.v-if-vs-v-show/"},{"content":"计算属性 vs 方法 vs 侦听属性 API 如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推","lvl0":"计算属性 vs 方法 vs 侦听属性","lvl1":["《Vue》笔记","基础"],"lvl2":"摘要","objectID":"501dfbcbb1f39b86605594bc8891e82c","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80/20.%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E6%96%B9%E6%B3%95-vs-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"content":"实例生命周期钩子 实例生命周期钩子API 简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15","lvl0":"生命周期","lvl1":["《Vue》笔记","基础"],"lvl2":"摘要","objectID":"71e512657738e14621661baa9925043e","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80/10.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"content":"路由懒加载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 路由同步加载 // import Recommend from \u0026#39;@/components/recommend/recommend\u0026#39; // import Singer from \u0026#39;@/components/singer/singer\u0026#39; // import Rank from \u0026#39;@/components/rank/rank\u0026#39; // import Search from \u0026#39;@/components/search/search\u0026#39; // import SingerDetail from \u0026#39;@/components/singer-detail/singer-detail\u0026#39; // import Disc from \u0026#39;@/components/disc/disc\u0026#39; // import TopList from \u0026#39;@/components/top-list/top-list\u0026#39; // import","lvl0":"路由懒加载","lvl1":["《Vue》笔记","规模化"],"lvl2":"摘要","objectID":"af9823a9c0dcb32df00f8461726f2bb3","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/06.%E8%A7%84%E6%A8%A1%E5%8C%96/140.%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"content":"transition-group列表过渡 列表的进入/离开过渡 1 2 3 \u0026lt;transition-group tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;!--tag转为ul--\u0026gt; \u0026lt;li v-for=\u0026#34;item in list\u0026#34; :key=\u0026#34;item\u0026#34;\u0026gt;{{item}}\u0026lt;/li\u0026gt; \u0026lt;!--子元素","lvl0":"transition-group列表过渡","lvl1":["《Vue》笔记","过渡\u0026动画"],"lvl2":"摘要","objectID":"1bb922361124f78e491aa3e259062da7","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/03.%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/120.transition-group%E5%88%97%E8%A1%A8%E8%BF%87%E6%B8%A1/"},{"content":"transition过渡\u0026amp;动画 API 使用 需要设置动画的元素或组件要在外边包裹一个\u0026lt;transition\u0026gt;标签，设置自定义的n","lvl0":"transition过渡\u0026动画","lvl1":["《Vue》笔记","过渡\u0026动画"],"lvl2":"摘要","objectID":"cca710ab83069102c1bcbf423a61fd1c","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/03.%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/110.transition%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/"},{"content":"vuex操作相关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { mapActions, mapMutations, mapGetters } from \u0026#39;vuex\u0026#39; computed: { ...mapGetters([ // 获取数据，内部为数组 \u0026#39;searchHistory\u0026#39; // 相当于在data插入searc","lvl0":"vuex操作相关","lvl1":["《Vue》笔记","规模化"],"lvl2":"摘要","objectID":"f21e710abe6b46294fe0fe7f1308c6d5","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/06.%E8%A7%84%E6%A8%A1%E5%8C%96/100.vuex%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"content":"操作本地缓存 https://github.com/ustbhuangyi/storage 操作 sessionStorage 和 localStorage 。","lvl0":"操作本地缓存","lvl1":["《Vue》笔记","其他"],"lvl2":"摘要","objectID":"8f2ad8108e171a5963017ab25ebf4bc9","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/99.%E5%85%B6%E4%BB%96/90.%E6%93%8D%E4%BD%9C%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"},{"content":"Vue中的防抖函数封装和使用 如搜索框中，每改变一个数值就请求一次搜索接口，当快速的改变数值时并不需要多次请求接口，这就需要一个防抖函数： 1 2","lvl0":"Vue中的防抖函数封装和使用","lvl1":["《Vue》笔记","其他"],"lvl2":"摘要","objectID":"7b9725eac27de025175dd4c23a82835a","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/99.%E5%85%B6%E4%BB%96/80.vue%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"content":"父组件调用子组件方法并传入值 通过ref引用调用子组件内的方法并传入参数 父组件： 1 2 3 4 5 6 7 \u0026lt;子组件标签 ref=\u0026#34;refNam","lvl0":"父组件调用子组件方法并传入值","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"c958ea21789b76b95b85fa58e874aae8","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/70.%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BC%A0%E5%85%A5%E5%80%BC/"},{"content":"兄弟组件传值 子组件1中把值传到父组件,父组件获取值传入子组件2 父组件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;子组件1 @方法名x=\u0026#34;方法","lvl0":"兄弟组件传值","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"f013958b3261b2ea936334c50c3b78a4","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/60.%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"},{"content":"子组件派发事件和值给父组件 API 子组件通过$emit派发事件和值给父组件（值可以有多个） 1 this.$emit(\u0026#39;fnX\u0026#39;, value) 父组件通过v-on绑定子组件派发的事件，并触发一个","lvl0":"子组件派发事件和值给父组件","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"da6088b200253160015490f26856763d","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/50.%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B4%BE%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%80%BC%E7%BB%99%E7%88%B6%E7%BB%84%E4%BB%B6/"},{"content":"父组件给子组件传值 父组件中，通过给子组件标签v-bind绑定属性的方式传入值 1 \u0026lt;ComponentName v-bind:name=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/ComponentName\u0026gt; 如果不使用v-bind传入的值为字符串，使用v-bind绑","lvl0":"父组件给子组件传值","lvl1":["《Vue》笔记","组件"],"lvl2":"摘要","objectID":"36fefe8182dcc90ae9ad39c89b9120c1","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/02.%E7%BB%84%E4%BB%B6/40.%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"},{"content":":::tip 说明：本章内容是博主的Vue学习笔记，以官方文档为准。 ::: MVVM模式 MVVM模式，M即 model，数据模型；V即 view，视图；VM即 vi","lvl0":"MVVM模式","lvl1":["《Vue》笔记","基础"],"lvl2":"摘要","objectID":"e4c3d418418c3dd3e043b15d54cef79b","tags":["Vue"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/10.vue%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80/00.mvvm%E6%A8%A1%E5%BC%8F/"},{"content":"","lvl0":"《Vue》笔记","lvl1":null,"lvl2":"摘要","objectID":"cd0abd4c6d2da3db5b21df1147720e41","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/02.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.vue%E7%AC%94%E8%AE%B0/"},{"content":"一个完美主义者的自我救赎 最近，看到一个心理测试题是测试你是否有完美主义： （1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？ （2）","lvl0":"一个完美主义者的自我救赎","lvl1":["更多","心情杂货"],"lvl2":"摘要","objectID":"757fc4947649e32476b0e7d27307b2d8","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/01.%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"},{"content":"","lvl0":"《ES6 教程》笔记","lvl1":null,"lvl2":"摘要","objectID":"6f0f46069aea6a536a5175ea121b0938","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/02.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"content":"说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源http://es6.ruanyifeng.com/，教程版权归原作者所有。 ECMAScript 6 简","lvl0":"ECMAScript 6 简介","lvl1":["《ES6 教程》笔记"],"lvl2":"摘要","objectID":"0efcc34c44d2ed8e490435239f81ff8e","tags":["ES6"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/07.es6-%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/01.ecmascript-6-%E7%AE%80%E4%BB%8B/"},{"content":"","lvl0":"《JavaScript教程》笔记","lvl1":null,"lvl2":"摘要","objectID":"32148c7b688e996528174bf6fa345b40","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/02.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/00.javascript%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"content":"DOM 一、概述 1、DOM DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用","lvl0":"DOM","lvl1":["《JavaScript教程》笔记"],"lvl2":"摘要","objectID":"0dcdf97f572d412e4e83dee242099aff","tags":["JavaScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/09.javascript%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/05.dom/"},{"content":"说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源https://wangdoc.com/javascript/，教程版权归原作者所","lvl0":"基础","lvl1":["《JavaScript教程》笔记"],"lvl2":"摘要","objectID":"acd1033fac0ceecd01b395a38b1cb9e1","tags":["JavaScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/09.javascript%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80/"},{"content":"浏览器模型 一、浏览器环境概述 JavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦","lvl0":"浏览器模型","lvl1":["《JavaScript教程》笔记"],"lvl2":"摘要","objectID":"8b2c9209851cdcb33f42da9cb1ea6b5e","tags":["JavaScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/09.javascript%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/07.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B/"},{"content":"面向对象编程 一、实例对象与new命令 1、对象是什么 面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它","lvl0":"面向对象","lvl1":["《JavaScript教程》笔记"],"lvl2":"摘要","objectID":"7e5c3505f10aaf73416b18c9d340eb4d","tags":["JavaScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/09.javascript%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/03.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"content":"内置对象篇 一、Object对象 1、概述 JavaScript 原生提供Object对象（注意起首的O是大写），本章介绍该对象原生的各种方法。 JavaScript 的所有其他对象都继承","lvl0":"内置对象","lvl1":["《JavaScript教程》笔记"],"lvl2":"摘要","objectID":"fb61434b2fb7c619388fc2ee559f749d","tags":["JavaScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/09.javascript%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/02.%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"},{"content":"事件 一、EventTarget 接口 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍","lvl0":"事件","lvl1":["《JavaScript教程》笔记"],"lvl2":"摘要","objectID":"be838590426ad95636d82028e335c979","tags":["JavaScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/09.javascript%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/06.%E4%BA%8B%E4%BB%B6/"},{"content":"异步操作 一、异步操作概述 1、单线程模型 单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一","lvl0":"异步操作","lvl1":["《JavaScript教程》笔记"],"lvl2":"摘要","objectID":"9aafc535c3ddcf5843e0897a9620847c","tags":["JavaScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/09.javascript%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/04.%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"},{"content":"axios 函数重载 需求分析 目前我们的 axios 函数只支持传入 1 个参数，如下： 1 2 3 4 5 6 7 axios({ url: \u0026#39;/extend/post\u0026#39;, method: \u0026#39;post\u0026#39;, data: { msg: \u0026#39;hi\u0026#39; } }) 我们希望该函数也能支持传入 2 个参数，如下： 1","lvl0":"axios 函数重载","lvl1":["《TypeScript 从零实现 axios》","ts-axios 接口扩展"],"lvl2":"摘要","objectID":"327614dfacb93aeb4e851bc676fbd980","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/06.ts-axios-%E6%8E%A5%E5%8F%A3%E6%89%A9%E5%B1%95/02.axios-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"},{"content":"Axios 实例模块单元测试 ts-axios 提供了 axios.create 静态方法，返回一个 instance 实例，我们需要对这个模块做测试。 测试代码编写 test/instance.spec.ts： 1 2","lvl0":"Axios 实例模块单元测试","lvl1":["《TypeScript 从零实现 axios》","ts-axios 单元测试"],"lvl2":"摘要","objectID":"e66a6550b606c32d115d3648f014a20c","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/11.ts-axios-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/06.axios-%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"content":"baseURL 需求分析 有些时候，我们会请求某个域名下的多个接口，我们不希望每次发送请求都填写完整的 url，希望可以配置一个 baseURL，之后都可以传相","lvl0":"baseURL","lvl1":["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],"lvl2":"摘要","objectID":"b4fc19d1acf52ebda3c3f8700b020b35","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/10.ts-axios-%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/07.baseurl/"},{"content":"headers 模块单元测试 之前我们测试了 headers 的基础方法模块，接下来我们会从业务角度测试 headers 的相关业务逻辑。 测试代码编写 test/headers.spec.t","lvl0":"headers 模块单元测试","lvl1":["《TypeScript 从零实现 axios》","ts-axios 单元测试"],"lvl2":"摘要","objectID":"64e8da9dd6b83136a6c1337eabbcbb9e","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/11.ts-axios-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/05.headers-%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"content":"HTTP 授权 需求分析 HTTP 协议中的 Authorization 请求 header 会包含服务器用于验证用户代理身份的凭证，通常会在服务器返回 401 Unauthorized 状态码以及 WWW-Authenticate 消息头之后在后续请求中发送此消息头","lvl0":"HTTP 授权","lvl1":["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],"lvl2":"摘要","objectID":"d51fa0254d7892626d6bfc717b4bb94f","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/10.ts-axios-%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/04.http-%E6%8E%88%E6%9D%83/"},{"content":"Jest 安装和配置 Jest 安装 由于我们的项目是使用 typescript-library-starter 初始化的，已经内置了 Jest 的安装，但是安装的版本却不是最新的，我们可以对 package.json 中的相关依赖版本做修改，重新安","lvl0":"Jest 安装和配置","lvl1":["《TypeScript 从零实现 axios》","ts-axios 单元测试"],"lvl2":"摘要","objectID":"5870fa09570de31d62163fe1dd986b25","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/11.ts-axios-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/02.jest-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"content":"mergeConfig 模块单元测试 合并配置是 ts-axios 核心流程中非常重要的一个环节，我们需要为它的各种情况去编写测试。 测试代码编写 test/mergeConfig.sp","lvl0":"mergeConfig 模块单元测试","lvl1":["《TypeScript 从零实现 axios》","ts-axios 单元测试"],"lvl2":"摘要","objectID":"9d902db94ee0d7b8e4a596d0566fbd28","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/11.ts-axios-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/08.mergeconfig-%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"content":"ts-axios 编译与发布 需求分析 前面的章节我们完成 ts-axios 库的代码编写和单元测试。这一章我们希望把代码部署发布到公共 npm 上，供别人下载使用。但是并不是所有人都会","lvl0":"ts-axios 编译与发布","lvl1":["《TypeScript 从零实现 axios》","ts-axios 部署与发布"],"lvl2":"摘要","objectID":"631b41902009f1a13dbae05ad5b4d556","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/12.ts-axios-%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8F%91%E5%B8%83/01.ts-axios-%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%91%E5%B8%83/"},{"content":"withCredentials 需求分析 有些时候我们会发一些跨域请求，比如 http://domain-a.com 站点发送一个 http://api.domain-b.com/get 的请求，默认情况下，浏览器会根据同源策略限制这种跨域请求，但是可以通过 CORS 技术解决","lvl0":"withCredentials","lvl1":["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],"lvl2":"摘要","objectID":"622df7256602497f2a569849ec87e82c","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/10.ts-axios-%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/01.withcredentials/"},{"content":"XSRF 防御 需求分析 XSRF 又名 CSRF，跨站请求伪造，它是前端常见的一种攻击方式，我们先通过一张图来认识它的攻击手段。 CSRF 的防御手段有很多，比如验证请求","lvl0":"XSRF 防御","lvl1":["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],"lvl2":"摘要","objectID":"0241585af3af9dec7a87e37d369ee66b","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/10.ts-axios-%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/02.xsrf-%E9%98%B2%E5%BE%A1/"},{"content":"编写基础请求代码 我们这节课开始编写 ts-axios 库，我们的目标是实现简单的发送请求功能，即客户端通过 XMLHttpRequest 对象把请求发送到 server 端，server 端能收到请求并响","lvl0":"编写基础请求代码","lvl1":["《TypeScript 从零实现 axios》","ts-axios 项目初始化"],"lvl2":"摘要","objectID":"e0b5a957b134b4a9a5f87e5958c4c21a","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/03.ts-axios-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/03.%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%A0%81/"},{"content":"初始化项目 创建代码仓库 接下来，我们开始初始化项目，首先我们先去 GitHub 上创建一个 repo，填好 repo 名称，以及写一下 README，对项目先做个简单的描","lvl0":"初始化项目","lvl1":["《TypeScript 从零实现 axios》","ts-axios 项目初始化"],"lvl2":"摘要","objectID":"6b02767f8f6402cbc587ded4a732d4d6","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/03.ts-axios-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/02.%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE/"},{"content":"处理请求 body 数据 需求分析 我们通过执行 XMLHttpRequest 对象实例的 send 方法来发送请求，并通过该方法的参数设置请求 body 数据，我们可以去 mdn 查阅该方法支持的参数类型。 我们","lvl0":"处理请求 body 数据","lvl1":["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],"lvl2":"摘要","objectID":"6b7d0e9c8d194476bd0363e00f584862","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/04.ts-axios-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/02.%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-body-%E6%95%B0%E6%8D%AE/"},{"content":"处理请求 header 需求分析 我们上节课遗留了一个问题： 1 2 3 4 5 6 7 8 axios({ method: \u0026#39;post\u0026#39;, url: \u0026#39;/base/post\u0026#39;, data: { a: 1, b: 2 } }) 我们做了请求数据的处理，把 data 转换成了 JSON 字符串，但是数据","lvl0":"处理请求 header","lvl1":["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],"lvl2":"摘要","objectID":"84b24712016cab5d8808d5e876ef63af","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/04.ts-axios-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/03.%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-header/"},{"content":"处理请求 url 参数 需求分析 还记得我们上节课遗留了一个问题，再来看这个例子： 1 2 3 4 5 6 7 8 axios({ method: \u0026#39;get\u0026#39;, url: \u0026#39;/base/get\u0026#39;, params: { a: 1, b: 2 } }) 我们希望最终请求的 url 是 /ba","lvl0":"处理请求 url 参数","lvl1":["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],"lvl2":"摘要","objectID":"cdc6748a116b7f72bb7f72fb71e9e6b6","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/04.ts-axios-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/01.%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82-url-%E5%8F%82%E6%95%B0/"},{"content":"处理响应 data 需求分析 在我们不去设置 responseType 的情况下，当服务端返回给我们的数据是字符串类型，我们可以尝试去把它转换成一个 JSON 对象。例如： 1 data: \u0026#34;{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2}\u0026#34; 我们把它转","lvl0":"处理响应 data","lvl1":["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],"lvl2":"摘要","objectID":"c917b2f454fed2c2f48c1ef8a017fd92","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/04.ts-axios-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/06.%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94-data/"},{"content":"处理响应 header 需求分析 我们通过 XMLHttpRequest 对象的 getAllResponseHeaders 方法获取到的值是如下一段字符串： 1 2 3 4 5 6 date: Fri, 05 Apr 2019 12:40:49 GMT etag: W/\u0026#34;d-Ssxx4FRxEutDLwo2+xkkxKc4y0k\u0026#34; connection: keep-alive x-powered-by: Express content-length: 13 content-type: application/json; charset=utf-8 每一行都是以回车符和换行","lvl0":"处理响应 header","lvl1":["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],"lvl2":"摘要","objectID":"925919a6e6ca99fa3a3aab8e195e83d8","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/04.ts-axios-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/05.%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94-header/"},{"content":"错误处理 需求分析 在上一章节，我们实现了 ts-axios 的基础功能，但目前为止我们都是处理了正常接收请求的逻辑，并没有考虑到任何错误情况的处理，这对于一个程","lvl0":"错误处理","lvl1":["《TypeScript 从零实现 axios》","ts-axios 异常情况处理"],"lvl2":"摘要","objectID":"e1f0abd6517f01db743501af4d0ef709","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/05.ts-axios-%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86/01.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"content":"错误信息增强 需求分析 上一节课我们已经捕获了几类 AJAX 的错误，但是对于错误信息提供的非常有限，我们希望对外提供的信息不仅仅包含错误文本信息，还包括","lvl0":"错误信息增强","lvl1":["《TypeScript 从零实现 axios》","ts-axios 异常情况处理"],"lvl2":"摘要","objectID":"62d5c5903709c8d392ae5e3f61d73a5d","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/05.ts-axios-%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86/02.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%BC%BA/"},{"content":"辅助模块单元测试 准备工作 通常我们会优先为一个库的辅助方法编写测试，我们会优先为 ts-axios 库的 helpers 目录下的模块编写测试。我们在 test 目录下创建一个 helpers 目录，创","lvl0":"辅助模块单元测试","lvl1":["《TypeScript 从零实现 axios》","ts-axios 单元测试"],"lvl2":"摘要","objectID":"17687bc93397dea0ebe692558dd23517","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/11.ts-axios-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/03.%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"content":"合并配置的设计与实现 需求分析 在之前的章节我们了解到，在发送请求的时候可以传入一个配置，来决定请求的不同行为。我们也希望 ts-axios 可以有默认配置，定义","lvl0":"合并配置的设计与实现","lvl1":["《TypeScript 从零实现 axios》","ts-axios 配置化实现"],"lvl2":"摘要","objectID":"c5c347fb1d1149f2fd5ae2cc5f365c17","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/08.ts-axios-%E9%85%8D%E7%BD%AE%E5%8C%96%E5%AE%9E%E7%8E%B0/01.%E5%90%88%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"content":"获取响应数据 需求分析 在前面的章节中，我们发送的请求都可以从网络层面接收到服务端返回的数据，但是代码层面并没有做任何关于返回数据的处理。我们希","lvl0":"获取响应数据","lvl1":["《TypeScript 从零实现 axios》","ts-axios 基础功能实现"],"lvl2":"摘要","objectID":"ed9d8d4b28ae9dd47a6ec4c12d25e75c","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/04.ts-axios-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/04.%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/"},{"content":"静态方法扩展 需求分析 官方 axios 库实现了 axios.all、axios.spread 等方法，它们的用法如下： 1 2 3 4 5 6 7 8 9 10 11 12 function getUserAccount() { return axios.get(\u0026#39;/user/12345\u0026#39;); } function","lvl0":"静态方法扩展","lvl1":["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],"lvl2":"摘要","objectID":"bf0aa9bb533eb5b8084f65466a1a8ba9","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/10.ts-axios-%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/08.%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%89%A9%E5%B1%95/"},{"content":"扩展 axios.create 静态接口 需求分析 目前为止，我们的 axios 都是一个单例，一旦我们修改了 axios 的默认配置，会影响所有的请求。我们希望提供了一个 axios.create 的静态接口允许我们创","lvl0":"扩展 create 静态接口","lvl1":["《TypeScript 从零实现 axios》","ts-axios 配置化实现"],"lvl2":"摘要","objectID":"7fdff7d05eae4b75c5ce17c7e4c9c4b6","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/08.ts-axios-%E9%85%8D%E7%BD%AE%E5%8C%96%E5%AE%9E%E7%8E%B0/03.%E6%89%A9%E5%B1%95-create-%E9%9D%99%E6%80%81%E6%8E%A5%E5%8F%A3/"},{"content":"扩展接口 需求分析 为了用户更加方便地使用 axios 发送请求，我们可以为所有支持请求方法扩展一些接口： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 如果使用了这些","lvl0":"扩展接口","lvl1":["《TypeScript 从零实现 axios》","ts-axios 接口扩展"],"lvl2":"摘要","objectID":"cd001eab58a1be216599225ad678ba13","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/06.ts-axios-%E6%8E%A5%E5%8F%A3%E6%89%A9%E5%B1%95/01.%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3/"},{"content":"拦截器模块单元测试 拦截器是 ts-axios 库一个非常实用的功能，接下来我们来编写它的测试代码。 测试代码编写 test/interceptor.spec.ts","lvl0":"拦截器模块单元测试","lvl1":["《TypeScript 从零实现 axios》","ts-axios 单元测试"],"lvl2":"摘要","objectID":"52893cf7cbb06c5e9213a646e5888298","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/11.ts-axios-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/07.%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"content":"拦截器设计与实现 需求分析 我们希望能对请求的发送和响应做拦截，也就是在发送请求之前和接收到响应之后做一些额外逻辑。 我们希望设计的拦截器的使用方","lvl0":"拦截器设计与实现","lvl1":["《TypeScript 从零实现 axios》","ts-axios 拦截器实现"],"lvl2":"摘要","objectID":"fde963035e170effe25247571a789536","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/07.ts-axios-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0/01.%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"content":"前言 单元测试是前端一个很重要的方向，鉴别一个开源库是否靠谱的一个标准是它的单元测试是否完善。有了完整的单元测试，未来你去重构现有代码或者是增","lvl0":"前言","lvl1":["《TypeScript 从零实现 axios》","ts-axios 单元测试"],"lvl2":"摘要","objectID":"d93f8e2026dedf2e66094bd75e235183","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/11.ts-axios-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/01.%E5%89%8D%E8%A8%80/"},{"content":"请求和响应配置化 需求分析 官方的 axios 库 给默认配置添加了 transformRequest 和 transformResponse 两个字段，它们的值是一个数组或者是一个函数。 其中 transformRequest 允许你在将请求数据发送到服务器之前","lvl0":"请求和响应配置化","lvl1":["《TypeScript 从零实现 axios》","ts-axios 配置化实现"],"lvl2":"摘要","objectID":"38f67b37439d67c32608e13ea798fcac","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/08.ts-axios-%E9%85%8D%E7%BD%AE%E5%8C%96%E5%AE%9E%E7%8E%B0/02.%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E9%85%8D%E7%BD%AE%E5%8C%96/"},{"content":"请求模块单元测试 请求模块是 axios 最基础的模块，通过一个 axios 方法发送 Ajax 请求。 jasmine-ajax Jasmine 是一个 BDD(行为驱动开发)的测试框架，它有很多成熟的插件，比如我们","lvl0":"请求模块单元测试","lvl1":["《TypeScript 从零实现 axios》","ts-axios 单元测试"],"lvl2":"摘要","objectID":"85303e6e18a7976ed27d2b3e632fbac3","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/11.ts-axios-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/04.%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"content":"请求取消模块单元测试 请求取消模块是 ts-axios 库核心流程其中一个分支，也是非常重要的模块，我们将从基础库和业务流程模块 2 个方面去编写单元测试。 Cancel 类单元","lvl0":"请求取消模块单元测试","lvl1":["《TypeScript 从零实现 axios》","ts-axios 单元测试"],"lvl2":"摘要","objectID":"7cb641887384cd230a37902a4039dea5","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/11.ts-axios-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/09.%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"content":"取消功能的设计与实现 需求分析 有些场景下，我们希望能主动取消请求，比如常见的搜索框案例，在用户输入过程中，搜索框的内容也在不断变化，正常情况每","lvl0":"取消功能的设计与实现","lvl1":["《TypeScript 从零实现 axios》","ts-axios 取消功能实现"],"lvl2":"摘要","objectID":"ff82335467948c0e49755a884a50b40c","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/09.ts-axios-%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/01.%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"content":"上传和下载的进度监控 需求分析 有些时候，当我们上传文件或者是请求一个大体积数据的时候，希望知道实时的进度，甚至可以基于此做一个进度条的展示。 我","lvl0":"上传和下载的进度监控","lvl1":["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],"lvl2":"摘要","objectID":"3b3f862f3c1ad36cd933663bfc2d822a","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/10.ts-axios-%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/03.%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%BF%9B%E5%BA%A6%E7%9B%91%E6%8E%A7/"},{"content":"剩余模块单元测试 defaults 模块单元测试 defaults 模块为请求配置提供了一些默认的属性和方法，我们需要为其编写单元测试。 test/defaults.spec.t","lvl0":"剩余模块单元测试","lvl1":["《TypeScript 从零实现 axios》","ts-axios 单元测试"],"lvl2":"摘要","objectID":"681666cc3f247971b53aeaf10c830af0","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/11.ts-axios-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/10.%E5%89%A9%E4%BD%99%E6%A8%A1%E5%9D%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"content":"响应数据支持泛型 需求分析 通常情况下，我们会把后端返回数据格式单独放入一个接口中： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 请求接口数据 export interface ResponseData\u0026lt;T","lvl0":"响应数据支持泛型","lvl1":["《TypeScript 从零实现 axios》","ts-axios 接口扩展"],"lvl2":"摘要","objectID":"8315670e5ad6da7d5d8f810eff0c2ef6","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/06.ts-axios-%E6%8E%A5%E5%8F%A3%E6%89%A9%E5%B1%95/03.%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B/"},{"content":"需求分析 接下来的章节，我们会使用 TypeScript 来重构 axios，重构之前，我们需要简单地做一些需求分析，看一下我们这次重构需要支持哪些 feature。 Features","lvl0":"需求分析","lvl1":["《TypeScript 从零实现 axios》","ts-axios 项目初始化"],"lvl2":"摘要","objectID":"936886919b12c0fa95594b717f915a16","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/03.ts-axios-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/01.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"},{"content":"引用 ts-axios 库 在 TS 项目中引用 我们借助于 vue-cli 脚手架创建一个 TypeScript 的 Vue 项目，然后我们把 Vue 官网上一段使用 axios 发请求的 demo 代码抄过来。 我们需要先执行 npm install ts-axios-new 安装 ts-axios 库。","lvl0":"引用 ts-axios 库","lvl1":["《TypeScript 从零实现 axios》","ts-axios 部署与发布"],"lvl2":"摘要","objectID":"6a173e7fd2fe3cb74d09710571da920c","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/12.ts-axios-%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8F%91%E5%B8%83/02.%E5%BC%95%E7%94%A8-ts-axios-%E5%BA%93/"},{"content":"自定义参数序列化 需求分析 在之前的章节，我们对请求的 url 参数做了处理，我们会解析传入的 params 对象，根据一定的规则把它解析成字符串，然后添加在 url 后面。","lvl0":"自定义参数序列化","lvl1":["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],"lvl2":"摘要","objectID":"322c97ca546cfcdedc850ce9eb0d0069","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/10.ts-axios-%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/06.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E5%BA%8F%E5%88%97%E5%8C%96/"},{"content":"自定义合法状态码 需求分析 之前 ts-axios 在处理响应结果的时候，认为 HTTP status 在 200 和 300 之间是一个合法值，在这个区间之外则创建一个错误。有些时候我们想自定义这个","lvl0":"自定义合法状态码","lvl1":["《TypeScript 从零实现 axios》","ts-axios 更多功能实现"],"lvl2":"摘要","objectID":"a212cf00a7e127027fa35d9eaa2dce83","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/10.ts-axios-%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%88%E6%B3%95%E7%8A%B6%E6%80%81%E7%A0%81/"},{"content":"","lvl0":"《TypeScript 从零实现 axios》","lvl1":null,"lvl2":"摘要","objectID":"03793cecc7bd6596fac9329aa86e8678","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/02.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.typescript-%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/"},{"content":"变量声明 let 和 const 是 JavaScript 里相对较新的变量声明方式。let 在很多方面与 var 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。const 是对 let 的一个增强","lvl0":"变量声明","lvl1":["《TypeScript 从零实现 axios》","TypeScript 常用语法"],"lvl2":"摘要","objectID":"f34f6ee8205ff8c5bfa9576ed23754a5","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/02.typescript-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/02.%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"},{"content":"泛型 软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在","lvl0":"泛型","lvl1":["《TypeScript 从零实现 axios》","TypeScript 常用语法"],"lvl2":"摘要","objectID":"1c6bf79bb50ee51545f9ec5ef9c7295f","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/02.typescript-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/06.%E6%B3%9B%E5%9E%8B/"},{"content":"高级类型 交叉类型 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，","lvl0":"高级类型","lvl1":["《TypeScript 从零实现 axios》","TypeScript 常用语法"],"lvl2":"摘要","objectID":"b4c4490ddf441e7c1f4521ec5ceccfe5","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/02.typescript-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/08.%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/"},{"content":"函数 函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的","lvl0":"函数","lvl1":["《TypeScript 从零实现 axios》","TypeScript 常用语法"],"lvl2":"摘要","objectID":"f2d64645716a43d76b80b85252f86289","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/02.typescript-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/05.%E5%87%BD%E6%95%B0/"},{"content":"基础类型 TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 布尔值 最基本的数据类型就是简单的 true/false 值，在JavaScript 和","lvl0":"基础类型","lvl1":["《TypeScript 从零实现 axios》","TypeScript 常用语法"],"lvl2":"摘要","objectID":"2bd8e8f8c2d7a515d021c2d90b5989f4","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/02.typescript-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/01.%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"},{"content":"接口 TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为","lvl0":"接口","lvl1":["《TypeScript 从零实现 axios》","TypeScript 常用语法"],"lvl2":"摘要","objectID":"5e7230a9dcd2eef00251c4547dcce803","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/02.typescript-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/03.%E6%8E%A5%E5%8F%A3/"},{"content":"类 对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是","lvl0":"类","lvl1":["《TypeScript 从零实现 axios》","TypeScript 常用语法"],"lvl2":"摘要","objectID":"81b6f20a3cd96c20750068f798a14096","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/02.typescript-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/04.%E7%B1%BB/"},{"content":"类型推断 这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。 基础 TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：","lvl0":"类型推断","lvl1":["《TypeScript 从零实现 axios》","TypeScript 常用语法"],"lvl2":"摘要","objectID":"d805459af6dd813254fea4feab8bb0da","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/02.typescript-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/07.%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/"},{"content":"安装 TypeScript 命令行运行如下命令，全局安装 TypeScript： 1 npm install -g typescript 安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)： 1 tsc -V","lvl0":"安装 TypeScript","lvl1":["《TypeScript 从零实现 axios》","初识 TypeScript"],"lvl2":"摘要","objectID":"3640fdaca73221506cec23f393a838d3","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/01.%E5%88%9D%E8%AF%86-typescript/02.%E5%AE%89%E8%A3%85-typescript/"},{"content":"编写第一个 TypeScript 程序 在编辑器，将下面的代码输入到 greeter.ts 文件里： 1 2 3 4 5 6 7 function greeter (person) { return \u0026#39;Hello, \u0026#39; + person } let user = \u0026#39;Yee\u0026#39; console.log(greeter(user)) 编译代码 我们使用了 .ts 扩展名，但是这段代码仅","lvl0":"编写第一个 TypeScript 程序","lvl1":["《TypeScript 从零实现 axios》","初识 TypeScript"],"lvl2":"摘要","objectID":"39754926198b87eb689ce996b6c994cf","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/01.%E5%88%9D%E8%AF%86-typescript/03.%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA-typescript-%E7%A8%8B%E5%BA%8F/"},{"content":"简介 TypeScript 作为 JavaScript 语言的超集，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健","lvl0":"简介","lvl1":["《TypeScript 从零实现 axios》","初识 TypeScript"],"lvl2":"摘要","objectID":"5c88b61952c857aeac5a7c9c7f63ba1a","tags":["TypeScript"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/11.typescript%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0-axios/01.%E5%88%9D%E8%AF%86-typescript/01.%E7%AE%80%E4%BB%8B/"},{"content":"判断是否为移动端浏览器 1 2 3 4 5 6 const flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if(flag){ // 移动端 } else { // PC端 }","lvl0":"判断是否为移动端浏览器","lvl1":["前端","JavaScript文章"],"lvl2":"摘要","objectID":"414419a4ae42a896555f647bcf202d82","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/01.javascript%E6%96%87%E7%AB%A0/60.%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"content":"提高学习效率的策略 推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用","lvl0":"提高学习效率的策略","lvl1":["更多","学习"],"lvl2":"摘要","objectID":"bef8e11f69eabb9654a1d3bfa3cee7aa","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/02.%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5/"},{"content":"处理问题的思路 工作中遇到问题？ 遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方","lvl0":"处理问题的思路","lvl1":["更多","学习"],"lvl2":"摘要","objectID":"8e46c9da5f134dddf5bdbf3377604058","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/05.%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF/"},{"content":"自律小建议 培养专注 练习冥想、瑜伽等 排除外界干扰 手机调到勿扰，在图书馆学习等 规定学习时间 番茄时间管理——使用番茄时间管理法，选择一个待完成的任","lvl0":"自律小建议","lvl1":["更多","学习"],"lvl2":"摘要","objectID":"ad817ef6b108c08bbf99d70a5b201835","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/04.%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE/"},{"content":"提高记忆的技巧 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。 重复记忆 每天留出半个到","lvl0":"提高记忆的技巧","lvl1":["更多","学习"],"lvl2":"摘要","objectID":"e5d498e66f93271608bc054033a3b5a5","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/03.%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"content":"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床 前言 Q：为什么要使用图床呢？什么是图床？ A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把","lvl0":"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床","lvl1":["技术","博客搭建"],"lvl2":"摘要","objectID":"fd8d5b26a3d43269943d79f2022f2c0e","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/03.github-+-jsdelivr-+-tinypng+-picgo-%E6%89%93%E9%80%A0%E7%A8%B3%E5%AE%9A%E5%BF%AB%E9%80%9F%E9%AB%98%E6%95%88%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/"},{"content":"GitHub Actions 定时运行代码：每天定时百度链接推送 博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入","lvl0":"GitHub Actions 定时运行代码：每天定时百度链接推送","lvl1":["技术","GitHub技巧"],"lvl2":"摘要","objectID":"c3064b1e881f7d01c77f327c1ab3e222","tags":["github","博客"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/02.github%E6%8A%80%E5%B7%A7/03.github-actions-%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%AF%8F%E5%A4%A9%E5%AE%9A%E6%97%B6%E7%99%BE%E5%BA%A6%E9%93%BE%E6%8E%A5%E6%8E%A8%E9%80%81/"},{"content":"GitHub Actions 实现自动部署静态博客 前言 我使用vuepress搭建了一个静态博客，挂在了Github pages和Coding pages上面。 coding pages","lvl0":"GitHub Actions 实现自动部署静态博客","lvl1":["技术","GitHub技巧"],"lvl2":"摘要","objectID":"8917abfbfc069a2f0e91bcba8bb106a2","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/02.github%E6%8A%80%E5%B7%A7/02.github-actions-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"},{"content":"nodejs递归读取所有文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var fs = require(\u0026#39;fs\u0026#39;); var path = require(\u0026#39;path\u0026#39;); function readFileList(dir, filesList = []) { const files = fs.readdirSync(dir); console.log(files); files.forEach((item, index) =\u0026gt; { var fullPath = path.join(dir, item); const stat = fs.statSync(fullPath); if (stat.isDirectory()) {","lvl0":"nodejs递归读取所有文件","lvl1":["技术","Nodejs"],"lvl2":"摘要","objectID":"22f27d48443ed1f448ac8a755aa79725","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/03.nodejs/01.nodejs%E9%80%92%E5%BD%92%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/"},{"content":"CSS3之animation动画 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。 ::: demo [vanilla] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16","lvl0":"CSS3之animation动画","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"23b020f87b114d1fc4e25930c3c02d8a","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/08.css3%E4%B9%8Banimation%E5%8A%A8%E7%94%BB/"},{"content":"CSS3之transition过渡 html结构 1 2 3 4 5 \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;div2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;div3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 先给元素设置transition过渡，指定样式和时间，这里设置al","lvl0":"CSS3之transition过渡","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"8dafe9dcd039d9095c07792472eba91c","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/07.css3%E4%B9%8Btransition%E8%BF%87%E6%B8%A1/"},{"content":"ES6面向对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 //面向对象封装 class","lvl0":"ES6面向对象","lvl1":["前端","JavaScript文章"],"lvl2":"摘要","objectID":"c6f4049fae8cc6bb6af2e87c4536257e","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/01.javascript%E6%96%87%E7%AB%A0/04.es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"content":"flex布局案例-基础 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。 ::: demo [vanilla] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21","lvl0":"flex布局案例-基础","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"e9161ec07fb21f050e415b39e86eb446","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/02.flex%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B-%E5%9F%BA%E7%A1%80/"},{"content":"flex布局案例-圣杯布局 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。 ::: demo [vanilla] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19","lvl0":"flex布局案例-圣杯布局","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"3b8deff4ebb0d25a84cb524a1c0687e5","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/04.flex%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/"},{"content":"flex布局案例-输入框布局 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。 ::: demo [vanilla] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18","lvl0":"flex布局案例-输入框布局","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"4d592c249a9566997718265689829c7c","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/06.flex%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B-%E8%BE%93%E5%85%A5%E6%A1%86%E5%B8%83%E5%B1%80/"},{"content":"flex布局案例-骰子 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。 ::: demo [vanilla] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21","lvl0":"flex布局案例-骰子","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"f785e672a989bfac521206c1bd129ccd","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/03.flex%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B-%E9%AA%B0%E5%AD%90/"},{"content":"flex布局案例-网格布局 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。 ::: demo [vanilla] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19","lvl0":"flex布局案例-网格布局","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"23d353f2b182fa45f03f58fb4de8d1cd","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/05.flex%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"},{"content":"flex布局语法 一、flex 布局是什么？ Flex是 Flexible Box 的缩写，意为\u0026quot;弹性布局\u0026quot;，用来为盒状模型提供最大的灵活性。 任何一个","lvl0":"flex布局语法","lvl1":["页面","CSS"],"lvl2":"摘要","objectID":"58e8df296a1f82f039d80cf6e1effda9","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/02.%E9%A1%B5%E9%9D%A2/20.css/01.flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/"},{"content":"GitHub高级搜索技巧 in:name \u0026lt;关键字\u0026gt; 仓库名称带关键字查询 in:description \u0026lt;关键字\u0026gt; 仓库描述带关键字查询 in:readme \u0026lt;关键字\u0026gt; RE","lvl0":"GitHub高级搜索技巧","lvl1":["技术","GitHub技巧"],"lvl2":"摘要","objectID":"2bb40004a90416f0726b98345691ce6e","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/02.github%E6%8A%80%E5%B7%A7/01.github%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"content":"Git使用手册 安装 官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。 安装完成后，在开始菜单里找","lvl0":"Git使用手册","lvl1":["技术","技术文档"],"lvl2":"摘要","objectID":"0fd636ecfed59431183b6a3b15b894b1","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/01.git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"},{"content":"Markdown使用教程 一、Markdown 简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 应用 当前许多网站都广泛使","lvl0":"Markdown使用教程","lvl1":["技术","技术文档"],"lvl2":"摘要","objectID":"d0a4d86bb05a5d02c403aca337e5cfe5","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/02.markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"content":"new命令原理 使用new命令时，它后面的函数依次执行下面的步骤： 创建一个空对象，作为将要返回的实例对象。 将这个空对象的原型，指向构造函数的p","lvl0":"new命令原理","lvl1":["前端","JavaScript文章"],"lvl2":"摘要","objectID":"5258f41d1e6b6b3ab27aa1abc2d1acf9","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/01.javascript%E6%96%87%E7%AB%A0/02.new%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86/"},{"content":"npm常用命令 简介 npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种： 允许用户从npm服务器下载别人编写的第三方包到本","lvl0":"npm常用命令","lvl1":["技术","技术文档"],"lvl2":"摘要","objectID":"6e894ed3176b4523734d7ce47a353eba","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/03.npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"content":"yaml语言教程 简介 YAML 是 \u0026ldquo;YAML Ain\u0026rsquo;t a Markup Language\u0026rdquo;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实","lvl0":"yaml语言教程","lvl1":["技术","技术文档"],"lvl2":"摘要","objectID":"d19d2ee26ed57685e53dc9a3e43a601c","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/15.yaml%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/"},{"content":"多种数组去重性能对比 测试模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 创建一个 1 ~ 10w 的数组，Array.from为ES6语法 let arr1 = Array.from(new Array(1000000),","lvl0":"多种数组去重性能对比","lvl1":["前端","JavaScript文章"],"lvl2":"摘要","objectID":"4086746fcc5095fe873e004aa11be293","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/01.javascript%E6%96%87%E7%AB%A0/06.%E5%A4%9A%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"content":"📚Blog 这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客\u0026amp;主题欢迎到GitHub点","lvl0":"关于","lvl1":null,"lvl2":"摘要","objectID":"cc5ed62f3bc3a7ebf779b6930eb1d251","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E/"},{"content":"解决百度无法收录搭建在GitHub上的静态博客的问题 ::: warning 如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。 ::: 背景 由于Gi","lvl0":"解决百度无法收录搭建在GitHub上的个人博客的问题","lvl1":["技术","博客搭建"],"lvl2":"摘要","objectID":"cfdf2cedf9eaf9d4e4037687c32920f8","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/01.%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E6%97%A0%E6%B3%95%E6%94%B6%E5%BD%95%E6%90%AD%E5%BB%BA%E5%9C%A8github%E4%B8%8A%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98/"},{"content":"面试问题集锦 请做一下自我介绍 回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者","lvl0":"面试问题集锦","lvl1":["更多","面试"],"lvl2":"摘要","objectID":"e154728bb4810cbe25c8edace93b25bf","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/03.%E9%9D%A2%E8%AF%95/01.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"},{"content":"使用Gitalk实现静态博客无后台评论系统 前言 Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。 下面我们来用它在vuepress搭建的博客中搭建","lvl0":"使用Gitalk实现静态博客无后台评论系统","lvl1":["技术","博客搭建"],"lvl2":"摘要","objectID":"900b86d4281d59e0b1e95509a330281d","tags":[""],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/02.%E4%BD%BF%E7%94%A8gitalk%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%97%A0%E5%90%8E%E5%8F%B0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"content":"小程序笔记 基础课程部分 微信公众平台 https://mp.weixin.qq.com/ 注册时可选择类型：订阅号、服务号、小程序、企业微信 每个邮箱仅能注册一个小程序。 个人类型小程序：无法使用微","lvl0":"小程序笔记","lvl1":["前端","学习笔记"],"lvl2":"摘要","objectID":"5af8d7b1df67a2073d5f01756f5692b9","tags":["小程序"],"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF/02.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/40.%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/"},{"content":"::: cardList 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68","lvl0":"友情链接","lvl1":null,"lvl2":"摘要","objectID":"cfda110842de76184d09c422ef9c2397","tags":null,"url":"https://lyr-2000.github.io/html/post/%E6%94%B6%E9%9B%86%E8%B5%84%E6%96%99/09.%E5%89%8D%E7%AB%AF/04.%E6%9B%B4%E5%A4%9A/99.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/"}]